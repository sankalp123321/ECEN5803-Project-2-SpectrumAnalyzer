<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Signal Analyzer: _ARM_DRIVER_STORAGE Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Signal Analyzer
   </div>
   <div id="projectbrief">STM32 based Singal Analyzer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">_ARM_DRIVER_STORAGE Struct Reference<div class="ingroups"><a class="el" href="group__hal.html">Hal</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_driver___storage_8h_source.html">Driver_Storage.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6b2e8a04c988254de711f9c3e0960aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal.html#ga2da88098fab5461030c0eadee5b60df0">ARM_DRIVER_VERSION</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a6b2e8a04c988254de711f9c3e0960aca">GetVersion</a> )(void)</td></tr>
<tr class="memdesc:a6b2e8a04c988254de711f9c3e0960aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get driver version.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a6b2e8a04c988254de711f9c3e0960aca">More...</a><br /></td></tr>
<tr class="separator:a6b2e8a04c988254de711f9c3e0960aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae557bd34ecb0ce8b303466a1b7a9bc68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal.html#ga185bc40c44d36020aed721491ebe0372">ARM_STORAGE_CAPABILITIES</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ae557bd34ecb0ce8b303466a1b7a9bc68">GetCapabilities</a> )(void)</td></tr>
<tr class="memdesc:ae557bd34ecb0ce8b303466a1b7a9bc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get driver capabilities.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ae557bd34ecb0ce8b303466a1b7a9bc68">More...</a><br /></td></tr>
<tr class="separator:ae557bd34ecb0ce8b303466a1b7a9bc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace259971bf934dd6d27c254e6c08d0a0"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ace259971bf934dd6d27c254e6c08d0a0">Initialize</a> )(<a class="el" href="group__hal.html#ga55adf95bab3afcb7da777ca0e8cc12ae">ARM_Storage_Callback_t</a> callback)</td></tr>
<tr class="memdesc:ace259971bf934dd6d27c254e6c08d0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Storage Interface.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ace259971bf934dd6d27c254e6c08d0a0">More...</a><br /></td></tr>
<tr class="separator:ace259971bf934dd6d27c254e6c08d0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9810795766f298c8d522e213984c3ea"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#aa9810795766f298c8d522e213984c3ea">Uninitialize</a> )(void)</td></tr>
<tr class="memdesc:aa9810795766f298c8d522e213984c3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize the Storage Interface.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#aa9810795766f298c8d522e213984c3ea">More...</a><br /></td></tr>
<tr class="separator:aa9810795766f298c8d522e213984c3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82ecf0c2a0cecd6ae9a4cb27be7c8de"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ae82ecf0c2a0cecd6ae9a4cb27be7c8de">PowerControl</a> )(<a class="el" href="group__hal.html#gaca1989b79e945ae368c00524b6e169fd">ARM_POWER_STATE</a> state)</td></tr>
<tr class="memdesc:ae82ecf0c2a0cecd6ae9a4cb27be7c8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the Storage interface power.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ae82ecf0c2a0cecd6ae9a4cb27be7c8de">More...</a><br /></td></tr>
<tr class="separator:ae82ecf0c2a0cecd6ae9a4cb27be7c8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c0eaab8c58af86c882ffa47552f840"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a23c0eaab8c58af86c882ffa47552f840">ReadData</a> )(uint64_t addr, void *data, uint32_t size)</td></tr>
<tr class="memdesc:a23c0eaab8c58af86c882ffa47552f840"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the contents of a given address range from the storage device.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a23c0eaab8c58af86c882ffa47552f840">More...</a><br /></td></tr>
<tr class="separator:a23c0eaab8c58af86c882ffa47552f840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b0c342a21576562693cd6d3c31d1a6"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a44b0c342a21576562693cd6d3c31d1a6">ProgramData</a> )(uint64_t addr, const void *data, uint32_t size)</td></tr>
<tr class="memdesc:a44b0c342a21576562693cd6d3c31d1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">program (write into) the contents of a given address range of the storage device.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a44b0c342a21576562693cd6d3c31d1a6">More...</a><br /></td></tr>
<tr class="separator:a44b0c342a21576562693cd6d3c31d1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9bda746bd0bf92edeb737e287d3aa3"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#aca9bda746bd0bf92edeb737e287d3aa3">Erase</a> )(uint64_t addr, uint32_t size)</td></tr>
<tr class="memdesc:aca9bda746bd0bf92edeb737e287d3aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase Storage range.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#aca9bda746bd0bf92edeb737e287d3aa3">More...</a><br /></td></tr>
<tr class="separator:aca9bda746bd0bf92edeb737e287d3aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6b1076cba9ee739453983bf9e2796d"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a0e6b1076cba9ee739453983bf9e2796d">EraseAll</a> )(void)</td></tr>
<tr class="memdesc:a0e6b1076cba9ee739453983bf9e2796d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase complete storage. Optional function for faster erase of the complete device.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a0e6b1076cba9ee739453983bf9e2796d">More...</a><br /></td></tr>
<tr class="separator:a0e6b1076cba9ee739453983bf9e2796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67da0a7a1d68d045630784ed0be6b059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hal.html#ga4db2d8a771a52ad94927601b3f71e6b3">ARM_STORAGE_STATUS</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a67da0a7a1d68d045630784ed0be6b059">GetStatus</a> )(void)</td></tr>
<tr class="memdesc:a67da0a7a1d68d045630784ed0be6b059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of the current (or previous) command executed by the storage controller; stored in the structure <a class="el" href="group__hal.html#ga4db2d8a771a52ad94927601b3f71e6b3">ARM_STORAGE_STATUS</a>.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a67da0a7a1d68d045630784ed0be6b059">More...</a><br /></td></tr>
<tr class="separator:a67da0a7a1d68d045630784ed0be6b059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0177ec62e668f743a902e80ff01747a"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#aa0177ec62e668f743a902e80ff01747a">GetInfo</a> )(<a class="el" href="group__hal.html#gafe5699d112436c0a1df43644f7eb273e">ARM_STORAGE_INFO</a> *info)</td></tr>
<tr class="memdesc:aa0177ec62e668f743a902e80ff01747a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about the Storage device; stored in the structure <a class="el" href="group__hal.html#gafe5699d112436c0a1df43644f7eb273e">ARM_STORAGE_INFO</a>.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#aa0177ec62e668f743a902e80ff01747a">More...</a><br /></td></tr>
<tr class="separator:aa0177ec62e668f743a902e80ff01747a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369c2ce89fd4728925f42cbe9c311ac5"><td class="memItemLeft" align="right" valign="top">uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a369c2ce89fd4728925f42cbe9c311ac5">ResolveAddress</a> )(uint64_t addr)</td></tr>
<tr class="memdesc:a369c2ce89fd4728925f42cbe9c311ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For memory-mapped storage, resolve an address relative to the storage controller into a memory address.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a369c2ce89fd4728925f42cbe9c311ac5">More...</a><br /></td></tr>
<tr class="separator:a369c2ce89fd4728925f42cbe9c311ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52624799b17137222e89d7a377de5bff"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a52624799b17137222e89d7a377de5bff">GetNextBlock</a> )(const <a class="el" href="group__hal.html#gacd48fac25335e93b80314e9baf8ea3d7">ARM_STORAGE_BLOCK</a> *prev_block, <a class="el" href="group__hal.html#gacd48fac25335e93b80314e9baf8ea3d7">ARM_STORAGE_BLOCK</a> *next_block)</td></tr>
<tr class="memdesc:a52624799b17137222e89d7a377de5bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance to the successor of the current block (iterator), or fetch the first block (if 'prev_block' is passed in as NULL).  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a52624799b17137222e89d7a377de5bff">More...</a><br /></td></tr>
<tr class="separator:a52624799b17137222e89d7a377de5bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf8b4cb67c12890aae46883acd3b2e0"><td class="memItemLeft" align="right" valign="top">int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#adcf8b4cb67c12890aae46883acd3b2e0">GetBlock</a> )(uint64_t addr, <a class="el" href="group__hal.html#gacd48fac25335e93b80314e9baf8ea3d7">ARM_STORAGE_BLOCK</a> *block)</td></tr>
<tr class="memdesc:adcf8b4cb67c12890aae46883acd3b2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the storage block (iterator) encompassing a given storage address.  <a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#adcf8b4cb67c12890aae46883acd3b2e0">More...</a><br /></td></tr>
<tr class="separator:adcf8b4cb67c12890aae46883acd3b2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This is the set of operations constituting the Storage driver. Their implementation is platform-specific, and needs to be supplied by the porting effort.</p>
<p >Some APIs within <code>ARM_DRIVER_STORAGE</code> will always operate synchronously: GetVersion, GetCapabilities, GetStatus, GetInfo, ResolveAddress, GetNextBlock, and GetBlock. This means that control returns to the caller with a relevant status code only after the completion of the operation (or the discovery of a failure condition).</p>
<p >The remainder of the APIs: Initialize, Uninitialize, PowerControl, ReadData, ProgramData, Erase, EraseAll, can function asynchronously if the underlying controller supports it&ndash;i.e. if <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. In the case of asynchronous operation, the invocation returns early (with ARM_DRIVER_OK) and results in a completion callback later. If <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is not set, then all such APIs execute synchronously, and control returns to the caller with a status code only after the completion of the operation (or the discovery of a failure condition).</p>
<p >If <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set, a storage driver may still choose to execute asynchronous operations in a synchronous manner. If so, the driver returns a positive value to indicate successful synchronous completion (or an error code in case of failure) and no further invocation of completion callback should be expected. The expected return value for synchronous completion of such asynchronous operations varies depending on the operation. For operations involving data access, it often equals the amount of data transferred or affected. For non data-transfer operations, such as EraseAll or Initialize, it is usually 1.</p>
<p >Here's a code snippet to suggest how asynchronous APIs might be used by callers to handle both synchronous and asynchronous execution by the underlying storage driver: </p><div class="fragment"><div class="line">ASSERT(<a class="code hl_define" href="group__hal.html#ga85752c5de59e8adeb001e35ff5be6be7">ARM_DRIVER_OK</a> == 0); <span class="comment">// this is a precondition; it doesn&#39;t need to be put in code</span></div>
<div class="line">int32_t returnValue = drv-&gt;asynchronousAPI(...);</div>
<div class="line"><span class="keywordflow">if</span> (returnValue &lt; <a class="code hl_define" href="group__hal.html#ga85752c5de59e8adeb001e35ff5be6be7">ARM_DRIVER_OK</a>) {</div>
<div class="line">    <span class="comment">// handle error.</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (returnValue == <a class="code hl_define" href="group__hal.html#ga85752c5de59e8adeb001e35ff5be6be7">ARM_DRIVER_OK</a>) {</div>
<div class="line">    ASSERT(drv-&gt;GetCapabilities().asynchronous_ops == 1);</div>
<div class="line">    <span class="comment">// handle early return from asynchronous execution; remainder of the work is done in the callback handler.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    ASSERT(returnValue == EXPECTED_RETURN_VALUE_FOR_SYNCHRONOUS_COMPLETION);</div>
<div class="line">    <span class="comment">// handle synchronous completion.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__hal_html_ga85752c5de59e8adeb001e35ff5be6be7"><div class="ttname"><a href="group__hal.html#ga85752c5de59e8adeb001e35ff5be6be7">ARM_DRIVER_OK</a></div><div class="ttdeci">#define ARM_DRIVER_OK</div><div class="ttdoc">Operation succeeded.</div><div class="ttdef"><b>Definition:</b> Driver_Common.h:41</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Data Documentation</h2>
<a id="aca9bda746bd0bf92edeb737e287d3aa3" name="aca9bda746bd0bf92edeb737e287d3aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9bda746bd0bf92edeb737e287d3aa3">&#9670;&nbsp;</a></span>Erase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::Erase) (uint64_t addr, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase Storage range. </p>
<p >This function erases a range of storage specified by [addr, addr + size). Both 'addr' and 'addr + size' should align with the 'erase_unit'(s) of the respective owning storage block(s) (see <a class="el" href="group__hal.html#gacd48fac25335e93b80314e9baf8ea3d7">ARM_STORAGE_BLOCK</a> and <a class="el" href="group__hal.html#gacba708b6c10ac6e2c6fbd584b90111d5">ARM_STORAGE_BLOCK_ATTRIBUTES</a>). The range to be erased will have its contents returned to the un-programmed state&ndash; i.e. to 'erased_value' (see <a class="el" href="group__hal.html#gacba708b6c10ac6e2c6fbd584b90111d5">ARM_STORAGE_BLOCK_ATTRIBUTES</a>), which is usually 1 to indicate the pattern of all ones: 0xFF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>This is the start-address of the range to be erased. It must start at an 'erase_unit' boundary of the underlying block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size (in bytes) of the range to be erased. 'addr + size' must be aligned with the 'erase_unit' of the underlying block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If the range to be erased doesn't align with the erase_units of the respective start and end blocks, ARM_DRIVER_ERROR_PARAMETER is returned. If any part of the range is protected, ARM_STORAGE_ERROR_PROTECTED is returned. If any part of the range is not erasable, ARM_STORAGE_ERROR_NOT_ERASABLE is returned. All such sanity-check failures result in the error code being returned synchronously and the storage bytes within the range remain unaffected. Otherwise the function executes in the following ways: If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with the number of successfully erased bytes passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a positive erase-count. Return values less than ARM_DRIVER_OK (0) signify errors.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#aca9bda746bd0bf92edeb737e287d3aa3" title="Erase Storage range.">Erase()</a> may return a smaller (positive) value than the size of the requested range. The returned value indicates the actual number of bytes erased. It is the caller's responsibility to follow up with an appropriate request to complete the operation.</dd>
<dd>
in the case of a failed erase (except when ARM_DRIVER_ERROR_PARAMETER, ARM_STORAGE_ERROR_PROTECTED, or ARM_STORAGE_ERROR_NOT_ERASABLE is returned synchronously), the requested range should be assumed to be in an unknown state. The previous contents may not be retained. </dd></dl>

</div>
</div>
<a id="a0e6b1076cba9ee739453983bf9e2796d" name="a0e6b1076cba9ee739453983bf9e2796d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6b1076cba9ee739453983bf9e2796d">&#9670;&nbsp;</a></span>EraseAll</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::EraseAll) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase complete storage. Optional function for faster erase of the complete device. </p>
<p >This optional function erases the complete device. If the device does not support global erase then the function returns the error value <a class="el" href="group__hal.html#ga2efa59e480d82697795439220e6884e4">ARM_DRIVER_ERROR_UNSUPPORTED</a>. The data field <em>'erase_all'</em> = 1 of the structure <a class="el" href="group__hal.html#ga185bc40c44d36020aed721491ebe0372">ARM_STORAGE_CAPABILITIES</a> encodes that ARM_STORAGE_EraseAll is supported.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If any part of the storage range is protected, ARM_STORAGE_ERROR_PROTECTED is returned. If any part of the storage range is not erasable, ARM_STORAGE_ERROR_NOT_ERASABLE is returned. All such sanity-check failures result in the error code being returned synchronously and the storage bytes within the range remain unaffected. Otherwise the function executes in the following ways: If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with ARM_DRIVER_OK passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="adcf8b4cb67c12890aae46883acd3b2e0" name="adcf8b4cb67c12890aae46883acd3b2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf8b4cb67c12890aae46883acd3b2e0">&#9670;&nbsp;</a></span>GetBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::GetBlock) (uint64_t addr, <a class="el" href="group__hal.html#gacd48fac25335e93b80314e9baf8ea3d7">ARM_STORAGE_BLOCK</a> *block)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the storage block (iterator) encompassing a given storage address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Storage address in bytes.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block</td><td>A caller-owned buffer large enough to be filled in with the ARM_STORAGE_BLOCK encapsulating the given address. This value can also be passed in as NULL if the caller isn't interested in populating a buffer with the block&ndash;if the caller only wishes to establish the presence of a containing storage block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARM_DRIVER_OK if a containing storage-block is found. In this case, if block is non-NULL, the buffer pointed to by it is populated with the contents of the storage block&ndash;i.e. if block is valid and a block is found, <a class="el" href="group__hal.html#ga955b1ca2ea24cfd3a8923731b581cfd4">ARM_STORAGE_VALID_BLOCK(block)</a> would return true following this call. If there is no storage block containing the given offset, or in case the driver is unable to resolve an address to a storage-block, an error (negative) value is returned and an invalid StorageBlock is populated into the supplied buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback. </dd></dl>

</div>
</div>
<a id="ae557bd34ecb0ce8b303466a1b7a9bc68" name="ae557bd34ecb0ce8b303466a1b7a9bc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae557bd34ecb0ce8b303466a1b7a9bc68">&#9670;&nbsp;</a></span>GetCapabilities</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal.html#ga185bc40c44d36020aed721491ebe0372">ARM_STORAGE_CAPABILITIES</a>(* _ARM_DRIVER_STORAGE::GetCapabilities) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get driver capabilities. </p>
<p >The function <a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ae557bd34ecb0ce8b303466a1b7a9bc68" title="Get driver capabilities.">GetCapabilities()</a> returns information about capabilities in this driver implementation. The data fields of the struct ARM_STORAGE_CAPABILITIES encode various capabilities, for example if the device is able to execute operations asynchronously.</p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code hl_struct" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html">ARM_DRIVER_STORAGE</a> *drv_info;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> read_capabilities (<span class="keywordtype">void</span>)  {</div>
<div class="line">  <a class="code hl_struct" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html">ARM_STORAGE_CAPABILITIES</a> drv_capabilities;</div>
<div class="line"> </div>
<div class="line">  drv_capabilities = drv_info-&gt;<a class="code hl_variable" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ae557bd34ecb0ce8b303466a1b7a9bc68">GetCapabilities</a> ();</div>
<div class="line">  <span class="comment">// interrogate capabilities</span></div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="astruct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e_html"><div class="ttname"><a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html">_ARM_DRIVER_STORAGE</a></div><div class="ttdef"><b>Definition:</b> Driver_Storage.h:292</div></div>
<div class="ttc" id="astruct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e_html_ae557bd34ecb0ce8b303466a1b7a9bc68"><div class="ttname"><a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ae557bd34ecb0ce8b303466a1b7a9bc68">_ARM_DRIVER_STORAGE::GetCapabilities</a></div><div class="ttdeci">ARM_STORAGE_CAPABILITIES(* GetCapabilities)(void)</div><div class="ttdoc">Get driver capabilities.</div><div class="ttdef"><b>Definition:</b> Driver_Storage.h:357</div></div>
<div class="ttc" id="astruct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s_html"><div class="ttname"><a href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html">_ARM_STORAGE_CAPABILITIES</a></div><div class="ttdoc">Storage Driver API Capabilities.</div><div class="ttdef"><b>Definition:</b> Driver_Storage.h:194</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__hal.html#ga185bc40c44d36020aed721491ebe0372">ARM_STORAGE_CAPABILITIES</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd>
<dd>
The function <a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ae557bd34ecb0ce8b303466a1b7a9bc68" title="Get driver capabilities.">GetCapabilities()</a> can be called any time to obtain the required information from the driver (even before initialization). It always returns the same information. </dd></dl>

</div>
</div>
<a id="aa0177ec62e668f743a902e80ff01747a" name="aa0177ec62e668f743a902e80ff01747a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0177ec62e668f743a902e80ff01747a">&#9670;&nbsp;</a></span>GetInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::GetInfo) (<a class="el" href="group__hal.html#gafe5699d112436c0a1df43644f7eb273e">ARM_STORAGE_INFO</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about the Storage device; stored in the structure <a class="el" href="group__hal.html#gafe5699d112436c0a1df43644f7eb273e">ARM_STORAGE_INFO</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>A caller-supplied buffer capable of being filled in with an <a class="el" href="group__hal.html#gafe5699d112436c0a1df43644f7eb273e">ARM_STORAGE_INFO</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARM_DRIVER_OK if a ARM_STORAGE_INFO structure containing top level metadata about the storage controller is filled into the supplied buffer, else an appropriate error value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is the caller's responsibility to ensure that the buffer passed in is able to be initialized with a <a class="el" href="group__hal.html#gafe5699d112436c0a1df43644f7eb273e">ARM_STORAGE_INFO</a>.</dd>
<dd>
This API returns synchronously&ndash;it does not result in an invocation of a completion callback. </dd></dl>

</div>
</div>
<a id="a52624799b17137222e89d7a377de5bff" name="a52624799b17137222e89d7a377de5bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52624799b17137222e89d7a377de5bff">&#9670;&nbsp;</a></span>GetNextBlock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::GetNextBlock) (const <a class="el" href="group__hal.html#gacd48fac25335e93b80314e9baf8ea3d7">ARM_STORAGE_BLOCK</a> *prev_block, <a class="el" href="group__hal.html#gacd48fac25335e93b80314e9baf8ea3d7">ARM_STORAGE_BLOCK</a> *next_block)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance to the successor of the current block (iterator), or fetch the first block (if 'prev_block' is passed in as NULL). </p>
<p >This helper function fetches (an iterator to) the next block (or the first block if 'prev_block' is passed in as NULL). In the failure case, a terminating, invalid block iterator is filled into the out parameter: 'next_block'. In combination with <a class="el" href="group__hal.html#ga955b1ca2ea24cfd3a8923731b581cfd4">ARM_STORAGE_VALID_BLOCK()</a>, it can be used to iterate over the sequence of blocks within the storage map:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="struct___a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">ARM_STORAGE_BLOCK</a> block;</div>
<div class="line"><span class="keywordflow">for</span> (drv-&gt;GetNextBlock(NULL, &amp;block); <a class="code hl_define" href="group__hal.html#ga955b1ca2ea24cfd3a8923731b581cfd4">ARM_STORAGE_VALID_BLOCK</a>(&amp;block); drv-&gt;GetNextBlock(&amp;block, &amp;block)) {</div>
<div class="line">    <span class="comment">// make use of block</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__hal_html_ga955b1ca2ea24cfd3a8923731b581cfd4"><div class="ttname"><a href="group__hal.html#ga955b1ca2ea24cfd3a8923731b581cfd4">ARM_STORAGE_VALID_BLOCK</a></div><div class="ttdeci">#define ARM_STORAGE_VALID_BLOCK(BLK)</div><div class="ttdef"><b>Definition:</b> Driver_Storage.h:94</div></div>
<div class="ttc" id="astruct___a_r_m___s_t_o_r_a_g_e___b_l_o_c_k_html"><div class="ttname"><a href="struct___a_r_m___s_t_o_r_a_g_e___b_l_o_c_k.html">_ARM_STORAGE_BLOCK</a></div><div class="ttdoc">A storage block is a range of memory with uniform attributes. Storage blocks combine to make up the a...</div><div class="ttdef"><b>Definition:</b> Driver_Storage.h:82</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prev_block</td><td>An existing block (iterator) within the same storage controller. The memory buffer holding this block is owned by the caller. This pointer may be NULL; if so, the invocation fills in the first block into the out parameter: 'next_block'.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next_block</td><td>A caller-owned buffer large enough to be filled in with the following ARM_STORAGE_BLOCK. It is legal to provide the same buffer using 'next_block' as was passed in with 'prev_block'. It is also legal to pass a NULL into this parameter if the caller isn't interested in populating a buffer with the next block&ndash;i.e. if the caller only wishes to establish the presence of a next block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ARM_DRIVER_OK if a valid next block is found (or first block, if prev_block is passed as NULL); upon successful operation, the contents of the next (or first) block are filled into the buffer pointed to by the parameter 'next_block' and <a class="el" href="group__hal.html#ga955b1ca2ea24cfd3a8923731b581cfd4">ARM_STORAGE_VALID_BLOCK(next_block)</a> is guaranteed to be true. Upon reaching the end of the sequence of blocks (iterators), or in case the driver is unable to fetch information about the next (or first) block, an error (negative) value is returned and an invalid StorageBlock is populated into the supplied buffer. If prev_block is NULL, the first block is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback. </dd></dl>

</div>
</div>
<a id="a67da0a7a1d68d045630784ed0be6b059" name="a67da0a7a1d68d045630784ed0be6b059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67da0a7a1d68d045630784ed0be6b059">&#9670;&nbsp;</a></span>GetStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal.html#ga4db2d8a771a52ad94927601b3f71e6b3">ARM_STORAGE_STATUS</a>(* _ARM_DRIVER_STORAGE::GetStatus) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of the current (or previous) command executed by the storage controller; stored in the structure <a class="el" href="group__hal.html#ga4db2d8a771a52ad94927601b3f71e6b3">ARM_STORAGE_STATUS</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The status of the underlying controller.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback. </dd></dl>

</div>
</div>
<a id="a6b2e8a04c988254de711f9c3e0960aca" name="a6b2e8a04c988254de711f9c3e0960aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2e8a04c988254de711f9c3e0960aca">&#9670;&nbsp;</a></span>GetVersion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hal.html#ga2da88098fab5461030c0eadee5b60df0">ARM_DRIVER_VERSION</a>(* _ARM_DRIVER_STORAGE::GetVersion) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get driver version. </p>
<p >The function <a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a6b2e8a04c988254de711f9c3e0960aca" title="Get driver version.">GetVersion()</a> returns version information of the driver implementation in ARM_DRIVER_VERSION.</p>
<ul>
<li>API version is the version of the CMSIS-Driver specification used to implement this driver.</li>
<li>Driver version is source code version of the actual driver implementation.</li>
</ul>
<p >Example: </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <a class="code hl_struct" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html">ARM_DRIVER_STORAGE</a> *drv_info;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> read_version (<span class="keywordtype">void</span>)  {</div>
<div class="line">  <a class="code hl_struct" href="struct___a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">ARM_DRIVER_VERSION</a>  version;</div>
<div class="line"> </div>
<div class="line">  version = drv_info-&gt;<a class="code hl_variable" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a6b2e8a04c988254de711f9c3e0960aca">GetVersion</a> ();</div>
<div class="line">  <span class="keywordflow">if</span> (version.<a class="code hl_variable" href="struct___a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html#a9cdfd94ad29da6e99e8b13ceefda899c">api</a> &lt; 0x10A)   {      <span class="comment">// requires at minimum API version 1.10 or higher</span></div>
<div class="line">    <span class="comment">// error handling</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="astruct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e_html_a6b2e8a04c988254de711f9c3e0960aca"><div class="ttname"><a href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a6b2e8a04c988254de711f9c3e0960aca">_ARM_DRIVER_STORAGE::GetVersion</a></div><div class="ttdeci">ARM_DRIVER_VERSION(* GetVersion)(void)</div><div class="ttdoc">Get driver version.</div><div class="ttdef"><b>Definition:</b> Driver_Storage.h:325</div></div>
<div class="ttc" id="astruct___a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n_html"><div class="ttname"><a href="struct___a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html">_ARM_DRIVER_VERSION</a></div><div class="ttdoc">Driver Version.</div><div class="ttdef"><b>Definition:</b> Driver_Common.h:35</div></div>
<div class="ttc" id="astruct___a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n_html_a9cdfd94ad29da6e99e8b13ceefda899c"><div class="ttname"><a href="struct___a_r_m___d_r_i_v_e_r___v_e_r_s_i_o_n.html#a9cdfd94ad29da6e99e8b13ceefda899c">_ARM_DRIVER_VERSION::api</a></div><div class="ttdeci">uint16_t api</div><div class="ttdoc">API version.</div><div class="ttdef"><b>Definition:</b> Driver_Common.h:36</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__hal.html#ga2da88098fab5461030c0eadee5b60df0">ARM_DRIVER_VERSION</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously&ndash;it does not result in an invocation of a completion callback.</dd>
<dd>
The function <a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#a6b2e8a04c988254de711f9c3e0960aca" title="Get driver version.">GetVersion()</a> can be called any time to obtain the required information from the driver (even before initialization). It always returns the same information. </dd></dl>

</div>
</div>
<a id="ace259971bf934dd6d27c254e6c08d0a0" name="ace259971bf934dd6d27c254e6c08d0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace259971bf934dd6d27c254e6c08d0a0">&#9670;&nbsp;</a></span>Initialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::Initialize) (<a class="el" href="group__hal.html#ga55adf95bab3afcb7da777ca0e8cc12ae">ARM_Storage_Callback_t</a> callback)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the Storage Interface. </p>
<p >The function Initialize is called when the middleware component starts operation. In addition to bringing the controller to a ready state, <a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ace259971bf934dd6d27c254e6c08d0a0" title="Initialize the Storage Interface.">Initialize()</a> receives a callback handler to be invoked upon completion of asynchronous operations.</p>
<p ><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ace259971bf934dd6d27c254e6c08d0a0" title="Initialize the Storage Interface.">Initialize()</a> needs to be called explicitly before powering the peripheral using <a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ae82ecf0c2a0cecd6ae9a4cb27be7c8de" title="Control the Storage interface power.">PowerControl()</a>, and before initiating other accesses to the storage controller.</p>
<p >The function performs the following operations:</p><ul>
<li>Initializes the resources needed for the Storage interface.</li>
<li>Registers the <a class="el" href="group__hal.html#ga55adf95bab3afcb7da777ca0e8cc12ae">ARM_Storage_Callback_t</a> callback function.</li>
</ul>
<p >To start working with a peripheral the functions Initialize and PowerControl need to be called in this order: drv-&gt;Initialize (...); // Allocate I/O pins drv-&gt;PowerControl (ARM_POWER_FULL); // Power up peripheral, setup IRQ/DMA</p>
<ul>
<li><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ace259971bf934dd6d27c254e6c08d0a0" title="Initialize the Storage Interface.">Initialize()</a> typically allocates the I/O resources (pins) for the peripheral. The function can be called multiple times; if the I/O resources are already initialized it performs no operation and just returns with ARM_DRIVER_OK.</li>
<li>PowerControl (ARM_POWER_FULL) sets the peripheral registers including interrupt (NVIC) and optionally DMA. The function can be called multiple times; if the registers are already set it performs no operation and just returns with ARM_DRIVER_OK.</li>
</ul>
<p >To stop working with a peripheral the functions PowerControl and Uninitialize need to be called in this order: drv-&gt;PowerControl (ARM_POWER_OFF); // Terminate any pending transfers, reset IRQ/DMA, power off peripheral drv-&gt;Uninitialize (...); // Release I/O pins</p>
<p >The functions PowerControl and Uninitialize always execute and can be used to put the peripheral into a Safe State, for example after any data transmission errors. To restart the peripheral in an error condition, you should first execute the Stop Sequence and then the Start Sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Caller-defined callback to be invoked upon command completion for asynchronous APIs (including the completion of initialization). Use a NULL pointer when no callback signals are required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with a status value of ARM_DRIVER_OK or an error-code. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="ae82ecf0c2a0cecd6ae9a4cb27be7c8de" name="ae82ecf0c2a0cecd6ae9a4cb27be7c8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82ecf0c2a0cecd6ae9a4cb27be7c8de">&#9670;&nbsp;</a></span>PowerControl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::PowerControl) (<a class="el" href="group__hal.html#gaca1989b79e945ae368c00524b6e169fd">ARM_POWER_STATE</a> state)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control the Storage interface power. </p>
<p >The function <b>ARM_Storage_PowerControl</b> operates the power modes of the Storage interface.</p>
<p >To start working with a peripheral the functions Initialize and PowerControl need to be called in this order: drv-&gt;Initialize (...); // Allocate I/O pins drv-&gt;PowerControl (ARM_POWER_FULL); // Power up peripheral, setup IRQ/DMA</p>
<ul>
<li><a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#ace259971bf934dd6d27c254e6c08d0a0" title="Initialize the Storage Interface.">Initialize()</a> typically allocates the I/O resources (pins) for the peripheral. The function can be called multiple times; if the I/O resources are already initialized it performs no operation and just returns with ARM_DRIVER_OK.</li>
<li>PowerControl (ARM_POWER_FULL) sets the peripheral registers including interrupt (NVIC) and optionally DMA. The function can be called multiple times; if the registers are already set it performs no operation and just returns with ARM_DRIVER_OK.</li>
</ul>
<p >To stop working with a peripheral the functions PowerControl and Uninitialize need to be called in this order: </p><pre class="fragment">drv-&gt;PowerControl (ARM_POWER_OFF);     // Terminate any pending transfers, reset IRQ/DMA, power off peripheral
drv-&gt;Uninitialize (...);               // Release I/O pins
</pre><p> The functions PowerControl and Uninitialize always execute and can be used to put the peripheral into a Safe State, for example after any data transmission errors. To restart the peripheral in an error condition, you should first execute the Stop Sequence and then the Start Sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td><a class="el" href="group__hal.html#gaca1989b79e945ae368c00524b6e169fd">ARM_POWER_STATE</a>. The target power-state for the storage controller. The parameter state can have the following values:<ul>
<li>ARM_POWER_FULL : set-up peripheral for data transfers, enable interrupts (NVIC) and optionally DMA. Can be called multiple times. If the peripheral is already in this mode, then the function performs no operation and returns with ARM_DRIVER_OK.</li>
<li>ARM_POWER_LOW : may use power saving. Returns ARM_DRIVER_ERROR_UNSUPPORTED when not implemented.</li>
<li>ARM_POWER_OFF : terminates any pending data transfers, disables peripheral, disables related interrupts and DMA.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with a status value of ARM_DRIVER_OK or an error-code. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="a44b0c342a21576562693cd6d3c31d1a6" name="a44b0c342a21576562693cd6d3c31d1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b0c342a21576562693cd6d3c31d1a6">&#9670;&nbsp;</a></span>ProgramData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::ProgramData) (uint64_t addr, const void *data, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>program (write into) the contents of a given address range of the storage device. </p>
<p >Write the contents of a given memory buffer into a range of storage memory. In the case of flash memory, the destination range in storage memory typically has its contents in an erased state from a preceding erase operation. The source memory buffer is owned by the caller and should remain accessible for the lifetime of this command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>This is the start address of the range to be written into. It needs to be aligned to the device's <em>program_unit</em> specified in <a class="el" href="group__hal.html#gafe5699d112436c0a1df43644f7eb273e">ARM_STORAGE_INFO</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The source of the write operation. The buffer is owned by the caller and should remain accessible for the lifetime of this command.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes requested to be written. The buffer should be at least as large as this size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>'size' should be a multiple of the device's 'program_unit' (see <a class="el" href="group__hal.html#gafe5699d112436c0a1df43644f7eb273e">ARM_STORAGE_INFO</a>).</dd>
<dd>
It is best for the middleware to write in units of 'optimal_program_unit' (<a class="el" href="group__hal.html#gafe5699d112436c0a1df43644f7eb273e">ARM_STORAGE_INFO</a>) of the device.</dd>
<dd>
This API may execute asynchronously if <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with the number of successfully transferred bytes passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a positive transfer-count. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="a23c0eaab8c58af86c882ffa47552f840" name="a23c0eaab8c58af86c882ffa47552f840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c0eaab8c58af86c882ffa47552f840">&#9670;&nbsp;</a></span>ReadData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::ReadData) (uint64_t addr, void *data, uint32_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read the contents of a given address range from the storage device. </p>
<p >Read the contents of a range of storage memory into a buffer supplied by the caller. The buffer is owned by the caller and should remain accessible for the lifetime of this command.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>This specifies the address from where to read data.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The destination of the read operation. The buffer is owned by the caller and should remain accessible for the lifetime of this command.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes requested to read. The data buffer should be at least as large as this size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with the number of successfully transferred bytes passed in as the 'status' parameter. In the case of synchronous execution, control returns after completion with a positive transfer-count. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<a id="a369c2ce89fd4728925f42cbe9c311ac5" name="a369c2ce89fd4728925f42cbe9c311ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369c2ce89fd4728925f42cbe9c311ac5">&#9670;&nbsp;</a></span>ResolveAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t(* _ARM_DRIVER_STORAGE::ResolveAddress) (uint64_t addr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For memory-mapped storage, resolve an address relative to the storage controller into a memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>This is the address for which we want a resolution to the processor's physical address space. It is an offset from the start of the storage map maintained by the owning storage controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resolved address in the processor's address space; else ARM_STORAGE_INVALID_ADDRESS, if no resolution is possible.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API returns synchronously. The invocation should return quickly, and result in a resolved address. </dd></dl>

</div>
</div>
<a id="aa9810795766f298c8d522e213984c3ea" name="aa9810795766f298c8d522e213984c3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9810795766f298c8d522e213984c3ea">&#9670;&nbsp;</a></span>Uninitialize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t(* _ARM_DRIVER_STORAGE::Uninitialize) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize the Storage Interface. </p>
<p >The function <a class="el" href="struct___a_r_m___d_r_i_v_e_r___s_t_o_r_a_g_e.html#aa9810795766f298c8d522e213984c3ea" title="De-initialize the Storage Interface.">Uninitialize()</a> de-initializes the resources of Storage interface.</p>
<p >It is called when the middleware component stops operation, and wishes to release the software resources used by the interface.</p>
<dl class="section note"><dt>Note</dt><dd>This API may execute asynchronously if <a class="el" href="struct___a_r_m___s_t_o_r_a_g_e___c_a_p_a_b_i_l_i_t_i_e_s.html#a296cfe4da04c764faaff24593d05be45">ARM_STORAGE_CAPABILITIES::asynchronous_ops</a> is set. Asynchronous execution is optional even if 'asynchronous_ops' is set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If asynchronous activity is launched, an invocation returns ARM_DRIVER_OK, and the caller can expect to receive a callback in the future with a status value of ARM_DRIVER_OK or an error-code. In the case of synchronous execution, control returns after completion with a value of 1. Return values less than ARM_DRIVER_OK (0) signify errors. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>D:/CUBoulder/MESA/ECEN5803-Project-2-SpectrumAnalyzer/Module_4/Keil/spectrum_analyzer_m4/mbed/hal/<a class="el" href="_driver___storage_8h_source.html">Driver_Storage.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
