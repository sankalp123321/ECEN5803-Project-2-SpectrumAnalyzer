<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Signal Analyzer: Convolution    &lt;br&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Signal Analyzer
   </div>
   <div id="projectbrief">STM32 based Singal Analyzer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Convolution &lt;br&gt;<div class="ingroups"><a class="el" href="group__group_filters.html">Filtering Functions</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3f860dc98c6fc4cafc421e4a2aed3c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___conv.html#ga3f860dc98c6fc4cafc421e4a2aed3c89">arm_conv_f32</a> (float32_t *pSrcA, uint32_t srcALen, float32_t *pSrcB, uint32_t srcBLen, float32_t *pDst)</td></tr>
<tr class="memdesc:ga3f860dc98c6fc4cafc421e4a2aed3c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution of floating-point sequences. <br  />
  <a href="group___conv.html#ga3f860dc98c6fc4cafc421e4a2aed3c89">More...</a><br /></td></tr>
<tr class="separator:ga3f860dc98c6fc4cafc421e4a2aed3c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf16f490d245391ec18a42adc73d6d749"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___conv.html#gaf16f490d245391ec18a42adc73d6d749">arm_conv_fast_opt_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst, q15_t *pScratch1, q15_t *pScratch2)</td></tr>
<tr class="memdesc:gaf16f490d245391ec18a42adc73d6d749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. <br  />
  <a href="group___conv.html#gaf16f490d245391ec18a42adc73d6d749">More...</a><br /></td></tr>
<tr class="separator:gaf16f490d245391ec18a42adc73d6d749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad75ca978ce906e04abdf86a8d76306d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___conv.html#gad75ca978ce906e04abdf86a8d76306d4">arm_conv_fast_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst)</td></tr>
<tr class="memdesc:gad75ca978ce906e04abdf86a8d76306d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. <br  />
  <a href="group___conv.html#gad75ca978ce906e04abdf86a8d76306d4">More...</a><br /></td></tr>
<tr class="separator:gad75ca978ce906e04abdf86a8d76306d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51112dcdf9b3624eb05182cdc4da9ec0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___conv.html#ga51112dcdf9b3624eb05182cdc4da9ec0">arm_conv_fast_q31</a> (q31_t *pSrcA, uint32_t srcALen, q31_t *pSrcB, uint32_t srcBLen, q31_t *pDst)</td></tr>
<tr class="memdesc:ga51112dcdf9b3624eb05182cdc4da9ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4.  <a href="group___conv.html#ga51112dcdf9b3624eb05182cdc4da9ec0">More...</a><br /></td></tr>
<tr class="separator:ga51112dcdf9b3624eb05182cdc4da9ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77dbcaef5c754cac27eab96c4753a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___conv.html#gac77dbcaef5c754cac27eab96c4753a3c">arm_conv_opt_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst, q15_t *pScratch1, q15_t *pScratch2)</td></tr>
<tr class="memdesc:gac77dbcaef5c754cac27eab96c4753a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution of Q15 sequences. <br  />
  <a href="group___conv.html#gac77dbcaef5c754cac27eab96c4753a3c">More...</a><br /></td></tr>
<tr class="separator:gac77dbcaef5c754cac27eab96c4753a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c7cf073e89d6d57cc4e711f078c3f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___conv.html#ga4c7cf073e89d6d57cc4e711f078c3f68">arm_conv_opt_q7</a> (q7_t *pSrcA, uint32_t srcALen, q7_t *pSrcB, uint32_t srcBLen, q7_t *pDst, q15_t *pScratch1, q15_t *pScratch2)</td></tr>
<tr class="memdesc:ga4c7cf073e89d6d57cc4e711f078c3f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution of Q7 sequences. <br  />
  <a href="group___conv.html#ga4c7cf073e89d6d57cc4e711f078c3f68">More...</a><br /></td></tr>
<tr class="separator:ga4c7cf073e89d6d57cc4e711f078c3f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd6a89b0ff7a94df64610598e6e6893"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___conv.html#gaccd6a89b0ff7a94df64610598e6e6893">arm_conv_q15</a> (q15_t *pSrcA, uint32_t srcALen, q15_t *pSrcB, uint32_t srcBLen, q15_t *pDst)</td></tr>
<tr class="memdesc:gaccd6a89b0ff7a94df64610598e6e6893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution of Q15 sequences. <br  />
  <a href="group___conv.html#gaccd6a89b0ff7a94df64610598e6e6893">More...</a><br /></td></tr>
<tr class="separator:gaccd6a89b0ff7a94df64610598e6e6893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946b58da734f1e4e78c91fcaab4b12b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___conv.html#ga946b58da734f1e4e78c91fcaab4b12b6">arm_conv_q31</a> (q31_t *pSrcA, uint32_t srcALen, q31_t *pSrcB, uint32_t srcBLen, q31_t *pDst)</td></tr>
<tr class="memdesc:ga946b58da734f1e4e78c91fcaab4b12b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution of Q31 sequences. <br  />
  <a href="group___conv.html#ga946b58da734f1e4e78c91fcaab4b12b6">More...</a><br /></td></tr>
<tr class="separator:ga946b58da734f1e4e78c91fcaab4b12b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2070cb792a167e78dbad8d06b97cdab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___conv.html#gae2070cb792a167e78dbad8d06b97cdab">arm_conv_q7</a> (q7_t *pSrcA, uint32_t srcALen, q7_t *pSrcB, uint32_t srcBLen, q7_t *pDst)</td></tr>
<tr class="memdesc:gae2070cb792a167e78dbad8d06b97cdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolution of Q7 sequences. <br  />
  <a href="group___conv.html#gae2070cb792a167e78dbad8d06b97cdab">More...</a><br /></td></tr>
<tr class="separator:gae2070cb792a167e78dbad8d06b97cdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >&lt;&gt;</p>
<p >Convolution is a mathematical operation that operates on two finite length vectors to generate a finite length output vector. <br  />
 Convolution is similar to correlation and is frequently used in filtering and data analysis. <br  />
 The CMSIS DSP library contains functions for convolving Q7, Q15, Q31, and floating-point data types. <br  />
 The library also provides fast versions of the Q15 and Q31 functions on Cortex-M4 and Cortex-M3. <br  />
</p>
<dl class="section user"><dt>Algorithm </dt><dd>Let <code>a[n]</code> and <code>b[n]</code> be sequences of length <code>srcALen</code> and <code>srcBLen</code> samples respectively. <br  />
 Then the convolution <br  />
</dd></dl>
<pre>    
                  c[n] = a[n] * b[n]    
</pre><p> <br  />
</p>
<dl class="section user"><dt></dt><dd>is defined as <br  />
 <div class="image">
<img src="ConvolutionEquation.gif" alt=""/>
</div>
 </dd></dl>
<dl class="section user"><dt></dt><dd>Note that <code>c[n]</code> is of length <code>srcALen + srcBLen - 1</code> and is defined over the interval <code>n=0, 1, 2, ..., srcALen + srcBLen - 2</code>. <br  />
 <code>pSrcA</code> points to the first input vector of length <code>srcALen</code> and <br  />
 <code>pSrcB</code> points to the second input vector of length <code>srcBLen</code>. <br  />
 The output result is written to <code>pDst</code> and the calling function must allocate <code>srcALen+srcBLen-1</code> words for the result. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>Conceptually, when two signals <code>a[n]</code> and <code>b[n]</code> are convolved, <br  />
 the signal <code>b[n]</code> slides over <code>a[n]</code>. <br  />
 For each offset <code>n</code>, the overlapping portions of a[n] and b[n] are multiplied and summed together. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>Note that convolution is a commutative operation: <br  />
</dd></dl>
<pre>    
                  a[n] * b[n] = b[n] * a[n].    
</pre><p> <br  />
</p>
<dl class="section user"><dt></dt><dd>This means that switching the A and B arguments to the convolution functions has no effect. <br  />
</dd></dl>
<p><b>Fixed-Point Behavior</b> <br  />
</p>
<dl class="section user"><dt></dt><dd>Convolution requires summing up a large number of intermediate products. <br  />
 As such, the Q7, Q15, and Q31 functions run a risk of overflow and saturation. <br  />
 Refer to the function specific documentation below for further details of the particular algorithm used. <br  />
</dd></dl>
<p><b>Fast Versions</b></p>
<dl class="section user"><dt></dt><dd>Fast versions are supported for Q31 and Q15. Cycles for Fast versions are less compared to Q31 and Q15 of conv and the design requires the input signals should be scaled down to avoid intermediate overflows. <br  />
</dd></dl>
<p><b>Opt Versions</b></p>
<dl class="section user"><dt></dt><dd>Opt versions are supported for Q15 and Q7. Design uses internal scratch buffer for getting good optimisation. These versions are optimised in cycles and consumes more memory(Scratch memory) compared to Q15 and Q7 versions</dd></dl>
<p><br  />
</p>
<p >&lt;&gt;</p>
<p ><br  />
 </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3f860dc98c6fc4cafc421e4a2aed3c89" name="ga3f860dc98c6fc4cafc421e4a2aed3c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f860dc98c6fc4cafc421e4a2aed3c89">&#9670;&nbsp;</a></span>arm_conv_f32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_conv_f32 </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution of floating-point sequences. <br  />
 </p>
<p >Convolution of floating-point sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length srcALen+srcBLen-1. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. <br  />
 </dd></dl>

</div>
</div>
<a id="gaf16f490d245391ec18a42adc73d6d749" name="gaf16f490d245391ec18a42adc73d6d749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf16f490d245391ec18a42adc73d6d749">&#9670;&nbsp;</a></span>arm_conv_fast_opt_q15()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_conv_fast_opt_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. <br  />
 </p>
<p >Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length srcALen+srcBLen-1. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch1</td><td>points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch2</td><td>points to scratch buffer of size min(srcALen, srcBLen). <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. <br  />
</dd></dl>
<dl class="section user"><dt>Restrictions </dt><dd>If the silicon does not support unaligned memory access enable the macro UNALIGNED_SUPPORT_DISABLE <br  />
 In this case input, output, scratch1 and scratch2 buffers should be aligned by 32-bit <br  />
</dd></dl>
<p><b>Scaling and Overflow Behavior:</b> <br  />
</p>
<dl class="section user"><dt></dt><dd>This fast version uses a 32-bit accumulator with 2.30 format. <br  />
 The accumulator maintains full precision of the intermediate multiplication results <br  />
 but provides only a single guard bit. There is no saturation on intermediate additions. <br  />
 Thus, if the accumulator overflows it wraps around and distorts the result. <br  />
 The input signals should be scaled down to avoid intermediate overflows. <br  />
 Scale down the inputs by log2(min(srcALen, srcBLen)) (log2 is read as log to the base 2) times to avoid overflows, <br  />
 as maximum of min(srcALen, srcBLen) number of additions are carried internally. <br  />
 The 2.30 accumulator is right shifted by 15 bits and then saturated to 1.15 format to yield the final result. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___conv.html#gaccd6a89b0ff7a94df64610598e6e6893" title="Convolution of Q15 sequences.">arm_conv_q15()</a></code> for a slower implementation of this function which uses 64-bit accumulation to avoid wrap around distortion. <br  />
 </dd></dl>

</div>
</div>
<a id="gad75ca978ce906e04abdf86a8d76306d4" name="gad75ca978ce906e04abdf86a8d76306d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad75ca978ce906e04abdf86a8d76306d4">&#9670;&nbsp;</a></span>arm_conv_fast_q15()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_conv_fast_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4. <br  />
 </p>
<p >Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length srcALen+srcBLen-1. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. <br  />
</dd></dl>
<p><b>Scaling and Overflow Behavior:</b> <br  />
</p>
<dl class="section user"><dt></dt><dd>This fast version uses a 32-bit accumulator with 2.30 format. <br  />
 The accumulator maintains full precision of the intermediate multiplication results <br  />
 but provides only a single guard bit. There is no saturation on intermediate additions. <br  />
 Thus, if the accumulator overflows it wraps around and distorts the result. <br  />
 The input signals should be scaled down to avoid intermediate overflows. <br  />
 Scale down the inputs by log2(min(srcALen, srcBLen)) (log2 is read as log to the base 2) times to avoid overflows, <br  />
 as maximum of min(srcALen, srcBLen) number of additions are carried internally. <br  />
 The 2.30 accumulator is right shifted by 15 bits and then saturated to 1.15 format to yield the final result. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___conv.html#gaccd6a89b0ff7a94df64610598e6e6893" title="Convolution of Q15 sequences.">arm_conv_q15()</a></code> for a slower implementation of this function which uses 64-bit accumulation to avoid wrap around distortion. <br  />
 </dd></dl>

</div>
</div>
<a id="ga51112dcdf9b3624eb05182cdc4da9ec0" name="ga51112dcdf9b3624eb05182cdc4da9ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51112dcdf9b3624eb05182cdc4da9ec0">&#9670;&nbsp;</a></span>arm_conv_fast_q31()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_conv_fast_q31 </td>
          <td>(</td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length srcALen+srcBLen-1. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. <br  />
</dd></dl>
<p><br  />
 <b>Scaling and Overflow Behavior:</b> <br  />
</p>
<dl class="section user"><dt></dt><dd>This function is optimized for speed at the expense of fixed-point precision and overflow protection. <br  />
 The result of each 1.31 x 1.31 multiplication is truncated to 2.30 format. <br  />
 These intermediate results are accumulated in a 32-bit register in 2.30 format. <br  />
 Finally, the accumulator is saturated and converted to a 1.31 result. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>The fast version has the same overflow behavior as the standard version but provides less precision since it discards the low 32 bits of each multiplication result. <br  />
 In order to avoid overflows completely the input signals must be scaled down. <br  />
 Scale down the inputs by log2(min(srcALen, srcBLen)) (log2 is read as log to the base 2) times to avoid overflows, <br  />
 as maximum of min(srcALen, srcBLen) number of additions are carried internally. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___conv.html#ga946b58da734f1e4e78c91fcaab4b12b6" title="Convolution of Q31 sequences.">arm_conv_q31()</a></code> for a slower implementation of this function which uses 64-bit accumulation to provide higher precision. <br  />
 </dd></dl>

</div>
</div>
<a id="gac77dbcaef5c754cac27eab96c4753a3c" name="gac77dbcaef5c754cac27eab96c4753a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac77dbcaef5c754cac27eab96c4753a3c">&#9670;&nbsp;</a></span>arm_conv_opt_q15()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_conv_opt_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution of Q15 sequences. <br  />
 </p>
<p >Convolution of Q15 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length srcALen+srcBLen-1. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch1</td><td>points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch2</td><td>points to scratch buffer of size min(srcALen, srcBLen). <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. <br  />
</dd></dl>
<dl class="section user"><dt>Restrictions </dt><dd>If the silicon does not support unaligned memory access enable the macro UNALIGNED_SUPPORT_DISABLE <br  />
 In this case input, output, scratch1 and scratch2 buffers should be aligned by 32-bit <br  />
</dd></dl>
<p><br  />
 <b>Scaling and Overflow Behavior:</b> <br  />
</p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 64-bit internal accumulator. <br  />
 Both inputs are in 1.15 format and multiplications yield a 2.30 result. <br  />
 The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format. <br  />
 This approach provides 33 guard bits and there is no risk of overflow. <br  />
 The 34.30 result is then truncated to 34.15 format by discarding the low 15 bits and then saturated to 1.15 format. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>Refer to <code><a class="el" href="group___conv.html#gad75ca978ce906e04abdf86a8d76306d4" title="Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.">arm_conv_fast_q15()</a></code> for a faster but less precise version of this function for Cortex-M3 and Cortex-M4. <br  />
 </dd></dl>

</div>
</div>
<a id="ga4c7cf073e89d6d57cc4e711f078c3f68" name="ga4c7cf073e89d6d57cc4e711f078c3f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c7cf073e89d6d57cc4e711f078c3f68">&#9670;&nbsp;</a></span>arm_conv_opt_q7()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_conv_opt_q7 </td>
          <td>(</td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pScratch2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution of Q7 sequences. <br  />
 </p>
<p >Convolution of Q7 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length srcALen+srcBLen-1. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch1</td><td>points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pScratch2</td><td>points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen). <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. <br  />
</dd></dl>
<dl class="section user"><dt>Restrictions </dt><dd>If the silicon does not support unaligned memory access enable the macro UNALIGNED_SUPPORT_DISABLE <br  />
 In this case input, output, scratch1 and scratch2 buffers should be aligned by 32-bit <br  />
</dd></dl>
<p><br  />
 <b>Scaling and Overflow Behavior:</b> <br  />
</p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 32-bit internal accumulator. <br  />
 Both the inputs are represented in 1.7 format and multiplications yield a 2.14 result. <br  />
 The 2.14 intermediate results are accumulated in a 32-bit accumulator in 18.14 format. <br  />
 This approach provides 17 guard bits and there is no risk of overflow as long as <code>max(srcALen, srcBLen)&lt;131072</code>. <br  />
 The 18.14 result is then truncated to 18.7 format by discarding the low 7 bits and then saturated to 1.7 format. <br  />
 </dd></dl>

</div>
</div>
<a id="gaccd6a89b0ff7a94df64610598e6e6893" name="gaccd6a89b0ff7a94df64610598e6e6893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccd6a89b0ff7a94df64610598e6e6893">&#9670;&nbsp;</a></span>arm_conv_q15()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_conv_q15 </td>
          <td>(</td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q15_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution of Q15 sequences. <br  />
 </p>
<p >Convolution of Q15 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length srcALen+srcBLen-1. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. <br  />
</dd></dl>
<p><br  />
 <b>Scaling and Overflow Behavior:</b> <br  />
</p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 64-bit internal accumulator. <br  />
 Both inputs are in 1.15 format and multiplications yield a 2.30 result. <br  />
 The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format. <br  />
 This approach provides 33 guard bits and there is no risk of overflow. <br  />
 The 34.30 result is then truncated to 34.15 format by discarding the low 15 bits and then saturated to 1.15 format. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>Refer to <code><a class="el" href="group___conv.html#gad75ca978ce906e04abdf86a8d76306d4" title="Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.">arm_conv_fast_q15()</a></code> for a faster but less precise version of this function for Cortex-M3 and Cortex-M4.</dd></dl>
<dl class="section user"><dt></dt><dd>Refer the function <code><a class="el" href="group___conv.html#gac77dbcaef5c754cac27eab96c4753a3c" title="Convolution of Q15 sequences.">arm_conv_opt_q15()</a></code> for a faster implementation of this function using scratch buffers. </dd></dl>

</div>
</div>
<a id="ga946b58da734f1e4e78c91fcaab4b12b6" name="ga946b58da734f1e4e78c91fcaab4b12b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga946b58da734f1e4e78c91fcaab4b12b6">&#9670;&nbsp;</a></span>arm_conv_q31()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_conv_q31 </td>
          <td>(</td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q31_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution of Q31 sequences. <br  />
 </p>
<p >Convolution of Q31 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length srcALen+srcBLen-1. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. <br  />
</dd></dl>
<p><br  />
 <b>Scaling and Overflow Behavior:</b> <br  />
</p>
<dl class="section user"><dt></dt><dd>The function is implemented using an internal 64-bit accumulator. <br  />
 The accumulator has a 2.62 format and maintains full precision of the intermediate multiplication results but provides only a single guard bit. <br  />
 There is no saturation on intermediate additions. <br  />
 Thus, if the accumulator overflows it wraps around and distorts the result. <br  />
 The input signals should be scaled down to avoid intermediate overflows. <br  />
 Scale down the inputs by log2(min(srcALen, srcBLen)) (log2 is read as log to the base 2) times to avoid overflows, <br  />
 as maximum of min(srcALen, srcBLen) number of additions are carried internally. <br  />
 The 2.62 accumulator is right shifted by 31 bits and saturated to 1.31 format to yield the final result. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>See <code><a class="el" href="group___conv.html#ga51112dcdf9b3624eb05182cdc4da9ec0" title="Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4.">arm_conv_fast_q31()</a></code> for a faster but less precise implementation of this function for Cortex-M3 and Cortex-M4. <br  />
 </dd></dl>

</div>
</div>
<a id="gae2070cb792a167e78dbad8d06b97cdab" name="gae2070cb792a167e78dbad8d06b97cdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2070cb792a167e78dbad8d06b97cdab">&#9670;&nbsp;</a></span>arm_conv_q7()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void arm_conv_q7 </td>
          <td>(</td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcALen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pSrcB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcBLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">q7_t *&#160;</td>
          <td class="paramname"><em>pDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolution of Q7 sequences. <br  />
 </p>
<p >Convolution of Q7 sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcA</td><td>points to the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcALen</td><td>length of the first input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*pSrcB</td><td>points to the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcBLen</td><td>length of the second input sequence. <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*pDst</td><td>points to the location where the output result is written. Length srcALen+srcBLen-1. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. <br  />
</dd></dl>
<p><br  />
 <b>Scaling and Overflow Behavior:</b> <br  />
</p>
<dl class="section user"><dt></dt><dd>The function is implemented using a 32-bit internal accumulator. <br  />
 Both the inputs are represented in 1.7 format and multiplications yield a 2.14 result. <br  />
 The 2.14 intermediate results are accumulated in a 32-bit accumulator in 18.14 format. <br  />
 This approach provides 17 guard bits and there is no risk of overflow as long as <code>max(srcALen, srcBLen)&lt;131072</code>. <br  />
 The 18.14 result is then truncated to 18.7 format by discarding the low 7 bits and then saturated to 1.7 format. <br  />
</dd></dl>
<dl class="section user"><dt></dt><dd>Refer the function <code><a class="el" href="group___conv.html#ga4c7cf073e89d6d57cc4e711f078c3f68" title="Convolution of Q7 sequences.">arm_conv_opt_q7()</a></code> for a faster implementation of this function. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
