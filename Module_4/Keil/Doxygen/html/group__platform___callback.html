<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Signal Analyzer: Callback class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Signal Analyzer
   </div>
   <div id="projectbrief">STM32 based Singal Analyzer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Callback class<div class="ingroups"><a class="el" href="group__platform.html">Platform</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback.html">mbed::Callback&lt; F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_08_4.html">mbed::Callback&lt; R(A0)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_08_4.html">mbed::Callback&lt; R(A0, A1)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_00_01_a2_08_4.html">mbed::Callback&lt; R(A0, A1, A2)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_00_01_a2_00_01_a3_08_4.html">mbed::Callback&lt; R(A0, A1, A2, A3)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmbed_1_1_callback_3_01_r_07_a0_00_01_a1_00_01_a2_00_01_a3_00_01_a4_08_4.html">mbed::Callback&lt; R(A0, A1, A2, A3, A4)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4162849f549ae66f75bd485b81ab53fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga4162849f549ae66f75bd485b81ab53fc">MBED_ENABLE_IF_CALLBACK_COMPATIBLE</a>(F,  M)</td></tr>
<tr class="separator:ga4162849f549ae66f75bd485b81ab53fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8c554e299aa26216c4c34d9d822b05f8"><td class="memItemLeft" align="right" valign="top"><a id="ga8c554e299aa26216c4c34d9d822b05f8" name="ga8c554e299aa26216c4c34d9d822b05f8"></a>
typedef <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; void(int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::event_callback_t</b></td></tr>
<tr class="separator:ga8c554e299aa26216c4c34d9d822b05f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga79787577174689d1c0c7be04b08fc1d7"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ga79787577174689d1c0c7be04b08fc1d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga79787577174689d1c0c7be04b08fc1d7">mbed::callback</a> (R(*func)()=0)</td></tr>
<tr class="separator:ga79787577174689d1c0c7be04b08fc1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1701ad270d60caefefbab76f68d1760c"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:ga1701ad270d60caefefbab76f68d1760c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga1701ad270d60caefefbab76f68d1760c">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;func)</td></tr>
<tr class="separator:ga1701ad270d60caefefbab76f68d1760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56bd70769446943c650be3871120c17"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:gaa56bd70769446943c650be3871120c17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaa56bd70769446943c650be3871120c17">mbed::callback</a> (U *obj, R(T::*method)())</td></tr>
<tr class="separator:gaa56bd70769446943c650be3871120c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd90bf037410272a91c23963962210c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga0cd90bf037410272a91c23963962210c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga0cd90bf037410272a91c23963962210c">mbed::callback</a> (const U *obj, R(T::*method)() const)</td></tr>
<tr class="separator:ga0cd90bf037410272a91c23963962210c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69ed43c201888cf9062330471480bf34"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga69ed43c201888cf9062330471480bf34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga69ed43c201888cf9062330471480bf34">mbed::callback</a> (volatile U *obj, R(T::*method)() volatile)</td></tr>
<tr class="separator:ga69ed43c201888cf9062330471480bf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b4017ed78bafecd9536c407369013f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga15b4017ed78bafecd9536c407369013f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga15b4017ed78bafecd9536c407369013f">mbed::callback</a> (const volatile U *obj, R(T::*method)() const volatile)</td></tr>
<tr class="separator:ga15b4017ed78bafecd9536c407369013f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071229ea2c15481c2cb6a48fc9dbd2a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga071229ea2c15481c2cb6a48fc9dbd2a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga071229ea2c15481c2cb6a48fc9dbd2a8">mbed::callback</a> (R(*func)(T *), U *arg)</td></tr>
<tr class="separator:ga071229ea2c15481c2cb6a48fc9dbd2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f21d279de2bef76e93b3af4a2bb59c8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga3f21d279de2bef76e93b3af4a2bb59c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga3f21d279de2bef76e93b3af4a2bb59c8">mbed::callback</a> (R(*func)(const T *), const U *arg)</td></tr>
<tr class="separator:ga3f21d279de2bef76e93b3af4a2bb59c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3ca2401eb8ba233f15006d7f87ee6a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:gaae3ca2401eb8ba233f15006d7f87ee6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaae3ca2401eb8ba233f15006d7f87ee6a">mbed::callback</a> (R(*func)(volatile T *), volatile U *arg)</td></tr>
<tr class="separator:gaae3ca2401eb8ba233f15006d7f87ee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31e3ad3a0bf803414400c4016a07becf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga31e3ad3a0bf803414400c4016a07becf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga31e3ad3a0bf803414400c4016a07becf">mbed::callback</a> (R(*func)(const volatile T *), const volatile U *arg)</td></tr>
<tr class="separator:ga31e3ad3a0bf803414400c4016a07becf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga598e97b15c4d90f94aa1d1668d5cdcd0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R &gt; </td></tr>
<tr class="memitem:ga598e97b15c4d90f94aa1d1668d5cdcd0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga598e97b15c4d90f94aa1d1668d5cdcd0">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R()&gt; callback(U *obj</td></tr>
<tr class="separator:ga598e97b15c4d90f94aa1d1668d5cdcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa42c34c97ac84ef443c927ee60afbc1d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gaa42c34c97ac84ef443c927ee60afbc1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaa42c34c97ac84ef443c927ee60afbc1d">mbed::callback</a> (R(*func)(A0)=0)</td></tr>
<tr class="separator:gaa42c34c97ac84ef443c927ee60afbc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc57193c9e173b581700c39cb78627c0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gabc57193c9e173b581700c39cb78627c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gabc57193c9e173b581700c39cb78627c0">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;func)</td></tr>
<tr class="separator:gabc57193c9e173b581700c39cb78627c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e9edd2ec8c4a38d3d81b13d8dc8dc5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga22e9edd2ec8c4a38d3d81b13d8dc8dc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga22e9edd2ec8c4a38d3d81b13d8dc8dc5">mbed::callback</a> (U *obj, R(T::*method)(A0))</td></tr>
<tr class="separator:ga22e9edd2ec8c4a38d3d81b13d8dc8dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e6d698cd8d3988327e040be760ebacf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga9e6d698cd8d3988327e040be760ebacf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga9e6d698cd8d3988327e040be760ebacf">mbed::callback</a> (const U *obj, R(T::*method)(A0) const)</td></tr>
<tr class="separator:ga9e6d698cd8d3988327e040be760ebacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga555e63c5df84b0cfff5f07cfbdb9502f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga555e63c5df84b0cfff5f07cfbdb9502f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga555e63c5df84b0cfff5f07cfbdb9502f">mbed::callback</a> (volatile U *obj, R(T::*method)(A0) volatile)</td></tr>
<tr class="separator:ga555e63c5df84b0cfff5f07cfbdb9502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f1a4a142d0661b630a3f8e98ca1f902"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga0f1a4a142d0661b630a3f8e98ca1f902"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga0f1a4a142d0661b630a3f8e98ca1f902">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0) const volatile)</td></tr>
<tr class="separator:ga0f1a4a142d0661b630a3f8e98ca1f902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b818e85af8edc98cbac8f8645fbb848"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga1b818e85af8edc98cbac8f8645fbb848"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga1b818e85af8edc98cbac8f8645fbb848">mbed::callback</a> (R(*func)(T *, A0), U *arg)</td></tr>
<tr class="separator:ga1b818e85af8edc98cbac8f8645fbb848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258dc35a2d68be58f584376542df16be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga258dc35a2d68be58f584376542df16be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga258dc35a2d68be58f584376542df16be">mbed::callback</a> (R(*func)(const T *, A0), const U *arg)</td></tr>
<tr class="separator:ga258dc35a2d68be58f584376542df16be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad733151963f94f8ff104fe600640465f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:gad733151963f94f8ff104fe600640465f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gad733151963f94f8ff104fe600640465f">mbed::callback</a> (R(*func)(volatile T *, A0), volatile U *arg)</td></tr>
<tr class="separator:gad733151963f94f8ff104fe600640465f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585bd1d191125de31151106e9e69b407"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga585bd1d191125de31151106e9e69b407"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga585bd1d191125de31151106e9e69b407">mbed::callback</a> (R(*func)(const volatile T *, A0), const volatile U *arg)</td></tr>
<tr class="separator:ga585bd1d191125de31151106e9e69b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301526d02ad11b9014ffd1e03bc577b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 &gt; </td></tr>
<tr class="memitem:ga301526d02ad11b9014ffd1e03bc577b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga301526d02ad11b9014ffd1e03bc577b9">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0)&gt; callback(U *obj</td></tr>
<tr class="separator:ga301526d02ad11b9014ffd1e03bc577b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd4e7d3b013591d25525ff29714651e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga9fd4e7d3b013591d25525ff29714651e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga9fd4e7d3b013591d25525ff29714651e">mbed::callback</a> (R(*func)(A0, A1)=0)</td></tr>
<tr class="separator:ga9fd4e7d3b013591d25525ff29714651e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38777cfe4734cf78af9db263d55be972"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga38777cfe4734cf78af9db263d55be972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga38777cfe4734cf78af9db263d55be972">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;func)</td></tr>
<tr class="separator:ga38777cfe4734cf78af9db263d55be972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga249bfa303889a67671725a58ffb975fb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga249bfa303889a67671725a58ffb975fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga249bfa303889a67671725a58ffb975fb">mbed::callback</a> (U *obj, R(T::*method)(A0, A1))</td></tr>
<tr class="separator:ga249bfa303889a67671725a58ffb975fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae30b7f1f64e1b15b485a60f2b8de7fc9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gae30b7f1f64e1b15b485a60f2b8de7fc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gae30b7f1f64e1b15b485a60f2b8de7fc9">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1) const)</td></tr>
<tr class="separator:gae30b7f1f64e1b15b485a60f2b8de7fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a07ae1a7775c694f82595ad4da5fabf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga0a07ae1a7775c694f82595ad4da5fabf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga0a07ae1a7775c694f82595ad4da5fabf">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1) volatile)</td></tr>
<tr class="separator:ga0a07ae1a7775c694f82595ad4da5fabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed87179a6287c3413f31e886b0745a9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gaed87179a6287c3413f31e886b0745a9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaed87179a6287c3413f31e886b0745a9c">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1) const volatile)</td></tr>
<tr class="separator:gaed87179a6287c3413f31e886b0745a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad466e7f91058dea8c57aef27ff40c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga2ad466e7f91058dea8c57aef27ff40c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga2ad466e7f91058dea8c57aef27ff40c9">mbed::callback</a> (R(*func)(T *, A0, A1), U *arg)</td></tr>
<tr class="separator:ga2ad466e7f91058dea8c57aef27ff40c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3472e49b56c143cf6d221f783983cb82"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga3472e49b56c143cf6d221f783983cb82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga3472e49b56c143cf6d221f783983cb82">mbed::callback</a> (R(*func)(const T *, A0, A1), const U *arg)</td></tr>
<tr class="separator:ga3472e49b56c143cf6d221f783983cb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac16c56c90ed9b15dddbc92b5f9d7c637"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:gac16c56c90ed9b15dddbc92b5f9d7c637"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gac16c56c90ed9b15dddbc92b5f9d7c637">mbed::callback</a> (R(*func)(volatile T *, A0, A1), volatile U *arg)</td></tr>
<tr class="separator:gac16c56c90ed9b15dddbc92b5f9d7c637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6237c2220c9df4ad188a3e6550647b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga1e6237c2220c9df4ad188a3e6550647b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga1e6237c2220c9df4ad188a3e6550647b">mbed::callback</a> (R(*func)(const volatile T *, A0, A1), const volatile U *arg)</td></tr>
<tr class="separator:ga1e6237c2220c9df4ad188a3e6550647b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f9e781941d03580345c71175307b53"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </td></tr>
<tr class="memitem:ga44f9e781941d03580345c71175307b53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga44f9e781941d03580345c71175307b53">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:ga44f9e781941d03580345c71175307b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a79d55a32e1d1ae294e9b3d3b72c823"><td class="memItemLeft" align="right" valign="top"><a id="ga6a79d55a32e1d1ae294e9b3d3b72c823" name="ga6a79d55a32e1d1ae294e9b3d3b72c823"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1))</td></tr>
<tr class="separator:ga6a79d55a32e1d1ae294e9b3d3b72c823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbdb16e4589e501b95b00aa6404046f4"><td class="memItemLeft" align="right" valign="top"><a id="gabbdb16e4589e501b95b00aa6404046f4" name="gabbdb16e4589e501b95b00aa6404046f4"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1))</td></tr>
<tr class="separator:gabbdb16e4589e501b95b00aa6404046f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e6268b0371ee9d06de1ecb0871c7415"><td class="memItemLeft" align="right" valign="top"><a id="ga6e6268b0371ee9d06de1ecb0871c7415" name="ga6e6268b0371ee9d06de1ecb0871c7415"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1))</td></tr>
<tr class="separator:ga6e6268b0371ee9d06de1ecb0871c7415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86fe08eb53a158beb1422d0cf86cb855"><td class="memItemLeft" align="right" valign="top"><a id="ga86fe08eb53a158beb1422d0cf86cb855" name="ga86fe08eb53a158beb1422d0cf86cb855"></a>
A1&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1))</td></tr>
<tr class="separator:ga86fe08eb53a158beb1422d0cf86cb855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893c318fb8c3b8b7210c7af76e909ae6"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga893c318fb8c3b8b7210c7af76e909ae6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga893c318fb8c3b8b7210c7af76e909ae6">mbed::callback</a> (R(*func)(A0, A1, A2)=0)</td></tr>
<tr class="separator:ga893c318fb8c3b8b7210c7af76e909ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d5528182a981ff04f6977d6e2d76a93"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga7d5528182a981ff04f6977d6e2d76a93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga7d5528182a981ff04f6977d6e2d76a93">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;func)</td></tr>
<tr class="separator:ga7d5528182a981ff04f6977d6e2d76a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd68cc0f404703de25bca4121852215"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga4dd68cc0f404703de25bca4121852215"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga4dd68cc0f404703de25bca4121852215">mbed::callback</a> (U *obj, R(T::*method)(A0, A1, A2))</td></tr>
<tr class="separator:ga4dd68cc0f404703de25bca4121852215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae06aaededf3704033212f2974ad5fb87"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gae06aaededf3704033212f2974ad5fb87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gae06aaededf3704033212f2974ad5fb87">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1, A2) const)</td></tr>
<tr class="separator:gae06aaededf3704033212f2974ad5fb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67ac071dd83fcfa7dca895334fd7d62"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gab67ac071dd83fcfa7dca895334fd7d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gab67ac071dd83fcfa7dca895334fd7d62">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2) volatile)</td></tr>
<tr class="separator:gab67ac071dd83fcfa7dca895334fd7d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95e9ae992de24e6dc0dbd554634030cc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga95e9ae992de24e6dc0dbd554634030cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga95e9ae992de24e6dc0dbd554634030cc">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2) const volatile)</td></tr>
<tr class="separator:ga95e9ae992de24e6dc0dbd554634030cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52516fa0337ec89d24f35783562da21"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gad52516fa0337ec89d24f35783562da21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gad52516fa0337ec89d24f35783562da21">mbed::callback</a> (R(*func)(T *, A0, A1, A2), U *arg)</td></tr>
<tr class="separator:gad52516fa0337ec89d24f35783562da21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga886aa59ea250bb96e7fc66974b99045a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga886aa59ea250bb96e7fc66974b99045a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga886aa59ea250bb96e7fc66974b99045a">mbed::callback</a> (R(*func)(const T *, A0, A1, A2), const U *arg)</td></tr>
<tr class="separator:ga886aa59ea250bb96e7fc66974b99045a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8977070245ca4b6f889ee9c6f98272"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:gaaf8977070245ca4b6f889ee9c6f98272"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gaaf8977070245ca4b6f889ee9c6f98272">mbed::callback</a> (R(*func)(volatile T *, A0, A1, A2), volatile U *arg)</td></tr>
<tr class="separator:gaaf8977070245ca4b6f889ee9c6f98272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ad8730eba2e5d12f41bcf588b06a5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga19ad8730eba2e5d12f41bcf588b06a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga19ad8730eba2e5d12f41bcf588b06a5c">mbed::callback</a> (R(*func)(const volatile T *, A0, A1, A2), const volatile U *arg)</td></tr>
<tr class="separator:ga19ad8730eba2e5d12f41bcf588b06a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10bb79c4ef863bc9917cbf446d7d0568"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </td></tr>
<tr class="memitem:ga10bb79c4ef863bc9917cbf446d7d0568"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga10bb79c4ef863bc9917cbf446d7d0568">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:ga10bb79c4ef863bc9917cbf446d7d0568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd464801649c6ff71316ed2373a66f1"><td class="memItemLeft" align="right" valign="top"><a id="ga7fd464801649c6ff71316ed2373a66f1" name="ga7fd464801649c6ff71316ed2373a66f1"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1, A2))</td></tr>
<tr class="separator:ga7fd464801649c6ff71316ed2373a66f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd770ad119c87748e4ed14af62840a3c"><td class="memItemLeft" align="right" valign="top"><a id="gabd770ad119c87748e4ed14af62840a3c" name="gabd770ad119c87748e4ed14af62840a3c"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1, A2))</td></tr>
<tr class="separator:gabd770ad119c87748e4ed14af62840a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eb0875e7ccc615234c1179bf5ef9907"><td class="memItemLeft" align="right" valign="top"><a id="ga1eb0875e7ccc615234c1179bf5ef9907" name="ga1eb0875e7ccc615234c1179bf5ef9907"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1, A2))</td></tr>
<tr class="separator:ga1eb0875e7ccc615234c1179bf5ef9907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga415e35bf19000e3e1a297e2b6dd4c33c"><td class="memItemLeft" align="right" valign="top"><a id="ga415e35bf19000e3e1a297e2b6dd4c33c" name="ga415e35bf19000e3e1a297e2b6dd4c33c"></a>
A2&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1, A2))</td></tr>
<tr class="separator:ga415e35bf19000e3e1a297e2b6dd4c33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga956f7b22c272c4573f48d56d82a75610"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga956f7b22c272c4573f48d56d82a75610"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga956f7b22c272c4573f48d56d82a75610">mbed::callback</a> (R(*func)(A0, A1, A2, A3)=0)</td></tr>
<tr class="separator:ga956f7b22c272c4573f48d56d82a75610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33bd6f7ae4bbedb4e6736662b2d3e086"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga33bd6f7ae4bbedb4e6736662b2d3e086"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga33bd6f7ae4bbedb4e6736662b2d3e086">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;func)</td></tr>
<tr class="separator:ga33bd6f7ae4bbedb4e6736662b2d3e086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf69fc2a2c3bf9b8ea95259b568e4c45"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gadf69fc2a2c3bf9b8ea95259b568e4c45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gadf69fc2a2c3bf9b8ea95259b568e4c45">mbed::callback</a> (U *obj, R(T::*method)(A0, A1, A2, A3))</td></tr>
<tr class="separator:gadf69fc2a2c3bf9b8ea95259b568e4c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcec10bfd9c27c41399bed7785339e52"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gafcec10bfd9c27c41399bed7785339e52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gafcec10bfd9c27c41399bed7785339e52">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1, A2, A3) const)</td></tr>
<tr class="separator:gafcec10bfd9c27c41399bed7785339e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe12e4221e4d09ed112f0c88e2dacb12"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gafe12e4221e4d09ed112f0c88e2dacb12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gafe12e4221e4d09ed112f0c88e2dacb12">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3) volatile)</td></tr>
<tr class="separator:gafe12e4221e4d09ed112f0c88e2dacb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ba70adb8e3e79de7fb7b05c2894655"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gae1ba70adb8e3e79de7fb7b05c2894655"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gae1ba70adb8e3e79de7fb7b05c2894655">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3) const volatile)</td></tr>
<tr class="separator:gae1ba70adb8e3e79de7fb7b05c2894655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga467859b73e3d8d6629943b983734c20b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga467859b73e3d8d6629943b983734c20b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga467859b73e3d8d6629943b983734c20b">mbed::callback</a> (R(*func)(T *, A0, A1, A2, A3), U *arg)</td></tr>
<tr class="separator:ga467859b73e3d8d6629943b983734c20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9425abebc78baae3a470f5abd501fbd1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga9425abebc78baae3a470f5abd501fbd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga9425abebc78baae3a470f5abd501fbd1">mbed::callback</a> (R(*func)(const T *, A0, A1, A2, A3), const U *arg)</td></tr>
<tr class="separator:ga9425abebc78baae3a470f5abd501fbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga684fc9526d04b2b95cde07200cae8aec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga684fc9526d04b2b95cde07200cae8aec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga684fc9526d04b2b95cde07200cae8aec">mbed::callback</a> (R(*func)(volatile T *, A0, A1, A2, A3), volatile U *arg)</td></tr>
<tr class="separator:ga684fc9526d04b2b95cde07200cae8aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48a08cdd23defe7e16283edf0b1f0c9e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:ga48a08cdd23defe7e16283edf0b1f0c9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga48a08cdd23defe7e16283edf0b1f0c9e">mbed::callback</a> (R(*func)(const volatile T *, A0, A1, A2, A3), const volatile U *arg)</td></tr>
<tr class="separator:ga48a08cdd23defe7e16283edf0b1f0c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58d69f185c10e920930a5dd1aebeca4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </td></tr>
<tr class="memitem:gae58d69f185c10e920930a5dd1aebeca4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gae58d69f185c10e920930a5dd1aebeca4">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:gae58d69f185c10e920930a5dd1aebeca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25161621af1037bf51ab84016adc41e6"><td class="memItemLeft" align="right" valign="top"><a id="ga25161621af1037bf51ab84016adc41e6" name="ga25161621af1037bf51ab84016adc41e6"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:ga25161621af1037bf51ab84016adc41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50fd76309106f1205f5fe8d1fb5793f8"><td class="memItemLeft" align="right" valign="top"><a id="ga50fd76309106f1205f5fe8d1fb5793f8" name="ga50fd76309106f1205f5fe8d1fb5793f8"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:ga50fd76309106f1205f5fe8d1fb5793f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae960785a3b20bb7d11aa116d2ef3159d"><td class="memItemLeft" align="right" valign="top"><a id="gae960785a3b20bb7d11aa116d2ef3159d" name="gae960785a3b20bb7d11aa116d2ef3159d"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:gae960785a3b20bb7d11aa116d2ef3159d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e9fdd9ee815f90a694fd10622729ae6"><td class="memItemLeft" align="right" valign="top"><a id="ga9e9fdd9ee815f90a694fd10622729ae6" name="ga9e9fdd9ee815f90a694fd10622729ae6"></a>
A3&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1, A2, A3))</td></tr>
<tr class="separator:ga9e9fdd9ee815f90a694fd10622729ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61814764ae4b4a4802dd47b290da69f"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:gab61814764ae4b4a4802dd47b290da69f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#gab61814764ae4b4a4802dd47b290da69f">mbed::callback</a> (R(*func)(A0, A1, A2, A3, A4)=0)</td></tr>
<tr class="separator:gab61814764ae4b4a4802dd47b290da69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85df50dd3a956e552bca6fe4b0f90501"><td class="memTemplParams" colspan="2">template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga85df50dd3a956e552bca6fe4b0f90501"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga85df50dd3a956e552bca6fe4b0f90501">mbed::callback</a> (const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;func)</td></tr>
<tr class="separator:ga85df50dd3a956e552bca6fe4b0f90501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c8ef76d1ef9ad360c39d1a877895b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga40c8ef76d1ef9ad360c39d1a877895b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga40c8ef76d1ef9ad360c39d1a877895b6">mbed::callback</a> (U *obj, R(T::*method)(A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:ga40c8ef76d1ef9ad360c39d1a877895b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633ebeae2024d03038f29e42e6e71bf5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga633ebeae2024d03038f29e42e6e71bf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga633ebeae2024d03038f29e42e6e71bf5">mbed::callback</a> (const U *obj, R(T::*method)(A0, A1, A2, A3, A4) const)</td></tr>
<tr class="separator:ga633ebeae2024d03038f29e42e6e71bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7552a7b7668edfa77c5230504170642a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga7552a7b7668edfa77c5230504170642a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga7552a7b7668edfa77c5230504170642a">mbed::callback</a> (volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) volatile)</td></tr>
<tr class="separator:ga7552a7b7668edfa77c5230504170642a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a50820affd6130c4c4b8932d29ee51d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga9a50820affd6130c4c4b8932d29ee51d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga9a50820affd6130c4c4b8932d29ee51d">mbed::callback</a> (const volatile U *obj, R(T::*method)(A0, A1, A2, A3, A4) const volatile)</td></tr>
<tr class="separator:ga9a50820affd6130c4c4b8932d29ee51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4477f99971a99df425de8905a8cd39bb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga4477f99971a99df425de8905a8cd39bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga4477f99971a99df425de8905a8cd39bb">mbed::callback</a> (R(*func)(T *, A0, A1, A2, A3, A4), U *arg)</td></tr>
<tr class="separator:ga4477f99971a99df425de8905a8cd39bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad3f0ce8b1736d861be9c570bf6b1b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga9ad3f0ce8b1736d861be9c570bf6b1b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga9ad3f0ce8b1736d861be9c570bf6b1b5">mbed::callback</a> (R(*func)(const T *, A0, A1, A2, A3, A4), const U *arg)</td></tr>
<tr class="separator:ga9ad3f0ce8b1736d861be9c570bf6b1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a61b2468eb9481fa2f206fef03613b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga7a61b2468eb9481fa2f206fef03613b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga7a61b2468eb9481fa2f206fef03613b9">mbed::callback</a> (R(*func)(volatile T *, A0, A1, A2, A3, A4), volatile U *arg)</td></tr>
<tr class="separator:ga7a61b2468eb9481fa2f206fef03613b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c9ab82acf82693e1cbedd5efc14933"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga48c9ab82acf82693e1cbedd5efc14933"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga48c9ab82acf82693e1cbedd5efc14933">mbed::callback</a> (R(*func)(const volatile T *, A0, A1, A2, A3, A4), const volatile U *arg)</td></tr>
<tr class="separator:ga48c9ab82acf82693e1cbedd5efc14933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523a7324cf927bf9614efeb64c557d66"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </td></tr>
<tr class="memitem:ga523a7324cf927bf9614efeb64c557d66"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__platform___callback.html#ga523a7324cf927bf9614efeb64c557d66">mbed::MBED_DEPRECATED_SINCE</a> (&quot;mbed-os-5.1&quot;, &quot;Arguments to callback have been reordered to callback(func, arg)&quot;) Callback&lt; R(A0</td></tr>
<tr class="separator:ga523a7324cf927bf9614efeb64c557d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07932813a1b77d4df478f3f4872cd4ff"><td class="memItemLeft" align="right" valign="top"><a id="ga07932813a1b77d4df478f3f4872cd4ff" name="ga07932813a1b77d4df478f3f4872cd4ff"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (U *obj, R(*func)(T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:ga07932813a1b77d4df478f3f4872cd4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22c19ca6c2ab41c071037ce9c42aa9d"><td class="memItemLeft" align="right" valign="top"><a id="gaf22c19ca6c2ab41c071037ce9c42aa9d" name="gaf22c19ca6c2ab41c071037ce9c42aa9d"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const U *obj, R(*func)(const T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gaf22c19ca6c2ab41c071037ce9c42aa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab36a23ed73fdb64410841161f07c05dc"><td class="memItemLeft" align="right" valign="top"><a id="gab36a23ed73fdb64410841161f07c05dc" name="gab36a23ed73fdb64410841161f07c05dc"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (volatile U *obj, R(*func)(volatile T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gab36a23ed73fdb64410841161f07c05dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae34aa30f64c3b8fe0bc2d5863bb04164"><td class="memItemLeft" align="right" valign="top"><a id="gae34aa30f64c3b8fe0bc2d5863bb04164" name="gae34aa30f64c3b8fe0bc2d5863bb04164"></a>
A4&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::callback</b> (const volatile U *obj, R(*func)(const volatile T *, A0, A1, A2, A3, A4))</td></tr>
<tr class="separator:gae34aa30f64c3b8fe0bc2d5863bb04164"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga689911b75562b995e216d5c4db982b64"><td class="memItemLeft" align="right" valign="top"><a id="ga689911b75562b995e216d5c4db982b64" name="ga689911b75562b995e216d5c4db982b64"></a>
R(*&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::func</b> )(T *))</td></tr>
<tr class="separator:ga689911b75562b995e216d5c4db982b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1039d88edb3bf471ffd231b2b9e674a5"><td class="memItemLeft" align="right" valign="top"><a id="ga1039d88edb3bf471ffd231b2b9e674a5" name="ga1039d88edb3bf471ffd231b2b9e674a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::A1</b></td></tr>
<tr class="separator:ga1039d88edb3bf471ffd231b2b9e674a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8fcdfa5c88334f1e8b265c3bc39c71"><td class="memItemLeft" align="right" valign="top"><a id="gaff8fcdfa5c88334f1e8b265c3bc39c71" name="gaff8fcdfa5c88334f1e8b265c3bc39c71"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::A2</b></td></tr>
<tr class="separator:gaff8fcdfa5c88334f1e8b265c3bc39c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae6936924cb2d9e94265195d8fdb8c8"><td class="memItemLeft" align="right" valign="top"><a id="gaeae6936924cb2d9e94265195d8fdb8c8" name="gaeae6936924cb2d9e94265195d8fdb8c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mbed::A3</b></td></tr>
<tr class="separator:gaeae6936924cb2d9e94265195d8fdb8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4162849f549ae66f75bd485b81ab53fc" name="ga4162849f549ae66f75bd485b81ab53fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4162849f549ae66f75bd485b81ab53fc">&#9670;&nbsp;</a></span>MBED_ENABLE_IF_CALLBACK_COMPATIBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MBED_ENABLE_IF_CALLBACK_COMPATIBLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">F, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">M&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">typename</span> detail::enable_if&lt;                                             \</div>
<div class="line">            detail::is_type&lt;M, &amp;F::operator()&gt;::value &amp;&amp;                    \</div>
<div class="line">            sizeof(F) &lt;= <span class="keyword">sizeof</span>(uintptr_t)                                  \</div>
<div class="line">        &gt;::type = detail::nil()</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1701ad270d60caefefbab76f68d1760c" name="ga1701ad270d60caefefbab76f68d1760c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1701ad270d60caefefbab76f68d1760c">&#9670;&nbsp;</a></span>callback() <span class="overload">[1/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gabc57193c9e173b581700c39cb78627c0" name="gabc57193c9e173b581700c39cb78627c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc57193c9e173b581700c39cb78627c0">&#9670;&nbsp;</a></span>callback() <span class="overload">[2/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga38777cfe4734cf78af9db263d55be972" name="ga38777cfe4734cf78af9db263d55be972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38777cfe4734cf78af9db263d55be972">&#9670;&nbsp;</a></span>callback() <span class="overload">[3/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga7d5528182a981ff04f6977d6e2d76a93" name="ga7d5528182a981ff04f6977d6e2d76a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d5528182a981ff04f6977d6e2d76a93">&#9670;&nbsp;</a></span>callback() <span class="overload">[4/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga33bd6f7ae4bbedb4e6736662b2d3e086" name="ga33bd6f7ae4bbedb4e6736662b2d3e086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33bd6f7ae4bbedb4e6736662b2d3e086">&#9670;&nbsp;</a></span>callback() <span class="overload">[5/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga85df50dd3a956e552bca6fe4b0f90501" name="ga85df50dd3a956e552bca6fe4b0f90501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85df50dd3a956e552bca6fe4b0f90501">&#9670;&nbsp;</a></span>callback() <span class="overload">[6/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga0cd90bf037410272a91c23963962210c" name="ga0cd90bf037410272a91c23963962210c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cd90bf037410272a91c23963962210c">&#9670;&nbsp;</a></span>callback() <span class="overload">[7/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga9e6d698cd8d3988327e040be760ebacf" name="ga9e6d698cd8d3988327e040be760ebacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e6d698cd8d3988327e040be760ebacf">&#9670;&nbsp;</a></span>callback() <span class="overload">[8/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gae30b7f1f64e1b15b485a60f2b8de7fc9" name="gae30b7f1f64e1b15b485a60f2b8de7fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae30b7f1f64e1b15b485a60f2b8de7fc9">&#9670;&nbsp;</a></span>callback() <span class="overload">[9/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gae06aaededf3704033212f2974ad5fb87" name="gae06aaededf3704033212f2974ad5fb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae06aaededf3704033212f2974ad5fb87">&#9670;&nbsp;</a></span>callback() <span class="overload">[10/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gafcec10bfd9c27c41399bed7785339e52" name="gafcec10bfd9c27c41399bed7785339e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcec10bfd9c27c41399bed7785339e52">&#9670;&nbsp;</a></span>callback() <span class="overload">[11/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga633ebeae2024d03038f29e42e6e71bf5" name="ga633ebeae2024d03038f29e42e6e71bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga633ebeae2024d03038f29e42e6e71bf5">&#9670;&nbsp;</a></span>callback() <span class="overload">[12/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga15b4017ed78bafecd9536c407369013f" name="ga15b4017ed78bafecd9536c407369013f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b4017ed78bafecd9536c407369013f">&#9670;&nbsp;</a></span>callback() <span class="overload">[13/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga0f1a4a142d0661b630a3f8e98ca1f902" name="ga0f1a4a142d0661b630a3f8e98ca1f902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f1a4a142d0661b630a3f8e98ca1f902">&#9670;&nbsp;</a></span>callback() <span class="overload">[14/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaed87179a6287c3413f31e886b0745a9c" name="gaed87179a6287c3413f31e886b0745a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed87179a6287c3413f31e886b0745a9c">&#9670;&nbsp;</a></span>callback() <span class="overload">[15/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga95e9ae992de24e6dc0dbd554634030cc" name="ga95e9ae992de24e6dc0dbd554634030cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95e9ae992de24e6dc0dbd554634030cc">&#9670;&nbsp;</a></span>callback() <span class="overload">[16/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gae1ba70adb8e3e79de7fb7b05c2894655" name="gae1ba70adb8e3e79de7fb7b05c2894655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ba70adb8e3e79de7fb7b05c2894655">&#9670;&nbsp;</a></span>callback() <span class="overload">[17/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga9a50820affd6130c4c4b8932d29ee51d" name="ga9a50820affd6130c4c4b8932d29ee51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a50820affd6130c4c4b8932d29ee51d">&#9670;&nbsp;</a></span>callback() <span class="overload">[18/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) const volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga79787577174689d1c0c7be04b08fc1d7" name="ga79787577174689d1c0c7be04b08fc1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79787577174689d1c0c7be04b08fc1d7">&#9670;&nbsp;</a></span>callback() <span class="overload">[19/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)()&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaa42c34c97ac84ef443c927ee60afbc1d" name="gaa42c34c97ac84ef443c927ee60afbc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa42c34c97ac84ef443c927ee60afbc1d">&#9670;&nbsp;</a></span>callback() <span class="overload">[20/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga9fd4e7d3b013591d25525ff29714651e" name="ga9fd4e7d3b013591d25525ff29714651e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fd4e7d3b013591d25525ff29714651e">&#9670;&nbsp;</a></span>callback() <span class="overload">[21/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga893c318fb8c3b8b7210c7af76e909ae6" name="ga893c318fb8c3b8b7210c7af76e909ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga893c318fb8c3b8b7210c7af76e909ae6">&#9670;&nbsp;</a></span>callback() <span class="overload">[22/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga956f7b22c272c4573f48d56d82a75610" name="ga956f7b22c272c4573f48d56d82a75610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga956f7b22c272c4573f48d56d82a75610">&#9670;&nbsp;</a></span>callback() <span class="overload">[23/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gab61814764ae4b4a4802dd47b290da69f" name="gab61814764ae4b4a4802dd47b290da69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab61814764ae4b4a4802dd47b290da69f">&#9670;&nbsp;</a></span>callback() <span class="overload">[24/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga3f21d279de2bef76e93b3af4a2bb59c8" name="ga3f21d279de2bef76e93b3af4a2bb59c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f21d279de2bef76e93b3af4a2bb59c8">&#9670;&nbsp;</a></span>callback() <span class="overload">[25/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga258dc35a2d68be58f584376542df16be" name="ga258dc35a2d68be58f584376542df16be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258dc35a2d68be58f584376542df16be">&#9670;&nbsp;</a></span>callback() <span class="overload">[26/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga3472e49b56c143cf6d221f783983cb82" name="ga3472e49b56c143cf6d221f783983cb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3472e49b56c143cf6d221f783983cb82">&#9670;&nbsp;</a></span>callback() <span class="overload">[27/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga886aa59ea250bb96e7fc66974b99045a" name="ga886aa59ea250bb96e7fc66974b99045a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga886aa59ea250bb96e7fc66974b99045a">&#9670;&nbsp;</a></span>callback() <span class="overload">[28/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga9425abebc78baae3a470f5abd501fbd1" name="ga9425abebc78baae3a470f5abd501fbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9425abebc78baae3a470f5abd501fbd1">&#9670;&nbsp;</a></span>callback() <span class="overload">[29/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga9ad3f0ce8b1736d861be9c570bf6b1b5" name="ga9ad3f0ce8b1736d861be9c570bf6b1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ad3f0ce8b1736d861be9c570bf6b1b5">&#9670;&nbsp;</a></span>callback() <span class="overload">[30/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga31e3ad3a0bf803414400c4016a07becf" name="ga31e3ad3a0bf803414400c4016a07becf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31e3ad3a0bf803414400c4016a07becf">&#9670;&nbsp;</a></span>callback() <span class="overload">[31/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga585bd1d191125de31151106e9e69b407" name="ga585bd1d191125de31151106e9e69b407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585bd1d191125de31151106e9e69b407">&#9670;&nbsp;</a></span>callback() <span class="overload">[32/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga1e6237c2220c9df4ad188a3e6550647b" name="ga1e6237c2220c9df4ad188a3e6550647b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6237c2220c9df4ad188a3e6550647b">&#9670;&nbsp;</a></span>callback() <span class="overload">[33/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga19ad8730eba2e5d12f41bcf588b06a5c" name="ga19ad8730eba2e5d12f41bcf588b06a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19ad8730eba2e5d12f41bcf588b06a5c">&#9670;&nbsp;</a></span>callback() <span class="overload">[34/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga48a08cdd23defe7e16283edf0b1f0c9e" name="ga48a08cdd23defe7e16283edf0b1f0c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48a08cdd23defe7e16283edf0b1f0c9e">&#9670;&nbsp;</a></span>callback() <span class="overload">[35/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga48c9ab82acf82693e1cbedd5efc14933" name="ga48c9ab82acf82693e1cbedd5efc14933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48c9ab82acf82693e1cbedd5efc14933">&#9670;&nbsp;</a></span>callback() <span class="overload">[36/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(const volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga071229ea2c15481c2cb6a48fc9dbd2a8" name="ga071229ea2c15481c2cb6a48fc9dbd2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga071229ea2c15481c2cb6a48fc9dbd2a8">&#9670;&nbsp;</a></span>callback() <span class="overload">[37/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga1b818e85af8edc98cbac8f8645fbb848" name="ga1b818e85af8edc98cbac8f8645fbb848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b818e85af8edc98cbac8f8645fbb848">&#9670;&nbsp;</a></span>callback() <span class="overload">[38/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga2ad466e7f91058dea8c57aef27ff40c9" name="ga2ad466e7f91058dea8c57aef27ff40c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad466e7f91058dea8c57aef27ff40c9">&#9670;&nbsp;</a></span>callback() <span class="overload">[39/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gad52516fa0337ec89d24f35783562da21" name="gad52516fa0337ec89d24f35783562da21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52516fa0337ec89d24f35783562da21">&#9670;&nbsp;</a></span>callback() <span class="overload">[40/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga467859b73e3d8d6629943b983734c20b" name="ga467859b73e3d8d6629943b983734c20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga467859b73e3d8d6629943b983734c20b">&#9670;&nbsp;</a></span>callback() <span class="overload">[41/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga4477f99971a99df425de8905a8cd39bb" name="ga4477f99971a99df425de8905a8cd39bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4477f99971a99df425de8905a8cd39bb">&#9670;&nbsp;</a></span>callback() <span class="overload">[42/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaae3ca2401eb8ba233f15006d7f87ee6a" name="gaae3ca2401eb8ba233f15006d7f87ee6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae3ca2401eb8ba233f15006d7f87ee6a">&#9670;&nbsp;</a></span>callback() <span class="overload">[43/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gad733151963f94f8ff104fe600640465f" name="gad733151963f94f8ff104fe600640465f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad733151963f94f8ff104fe600640465f">&#9670;&nbsp;</a></span>callback() <span class="overload">[44/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gac16c56c90ed9b15dddbc92b5f9d7c637" name="gac16c56c90ed9b15dddbc92b5f9d7c637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac16c56c90ed9b15dddbc92b5f9d7c637">&#9670;&nbsp;</a></span>callback() <span class="overload">[45/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaaf8977070245ca4b6f889ee9c6f98272" name="gaaf8977070245ca4b6f889ee9c6f98272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf8977070245ca4b6f889ee9c6f98272">&#9670;&nbsp;</a></span>callback() <span class="overload">[46/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga684fc9526d04b2b95cde07200cae8aec" name="ga684fc9526d04b2b95cde07200cae8aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga684fc9526d04b2b95cde07200cae8aec">&#9670;&nbsp;</a></span>callback() <span class="overload">[47/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga7a61b2468eb9481fa2f206fef03613b9" name="ga7a61b2468eb9481fa2f206fef03613b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a61b2468eb9481fa2f206fef03613b9">&#9670;&nbsp;</a></span>callback() <span class="overload">[48/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">R(*)(volatile T *, A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
    <tr><td class="paramname">arg</td><td>Pointer argument to function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gaa56bd70769446943c650be3871120c17" name="gaa56bd70769446943c650be3871120c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa56bd70769446943c650be3871120c17">&#9670;&nbsp;</a></span>callback() <span class="overload">[49/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)()&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga22e9edd2ec8c4a38d3d81b13d8dc8dc5" name="ga22e9edd2ec8c4a38d3d81b13d8dc8dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22e9edd2ec8c4a38d3d81b13d8dc8dc5">&#9670;&nbsp;</a></span>callback() <span class="overload">[50/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga249bfa303889a67671725a58ffb975fb" name="ga249bfa303889a67671725a58ffb975fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga249bfa303889a67671725a58ffb975fb">&#9670;&nbsp;</a></span>callback() <span class="overload">[51/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga4dd68cc0f404703de25bca4121852215" name="ga4dd68cc0f404703de25bca4121852215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd68cc0f404703de25bca4121852215">&#9670;&nbsp;</a></span>callback() <span class="overload">[52/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gadf69fc2a2c3bf9b8ea95259b568e4c45" name="gadf69fc2a2c3bf9b8ea95259b568e4c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf69fc2a2c3bf9b8ea95259b568e4c45">&#9670;&nbsp;</a></span>callback() <span class="overload">[53/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga40c8ef76d1ef9ad360c39d1a877895b6" name="ga40c8ef76d1ef9ad360c39d1a877895b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40c8ef76d1ef9ad360c39d1a877895b6">&#9670;&nbsp;</a></span>callback() <span class="overload">[54/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga69ed43c201888cf9062330471480bf34" name="ga69ed43c201888cf9062330471480bf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69ed43c201888cf9062330471480bf34">&#9670;&nbsp;</a></span>callback() <span class="overload">[55/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R()&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)() volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga555e63c5df84b0cfff5f07cfbdb9502f" name="ga555e63c5df84b0cfff5f07cfbdb9502f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga555e63c5df84b0cfff5f07cfbdb9502f">&#9670;&nbsp;</a></span>callback() <span class="overload">[56/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga0a07ae1a7775c694f82595ad4da5fabf" name="ga0a07ae1a7775c694f82595ad4da5fabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a07ae1a7775c694f82595ad4da5fabf">&#9670;&nbsp;</a></span>callback() <span class="overload">[57/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gab67ac071dd83fcfa7dca895334fd7d62" name="gab67ac071dd83fcfa7dca895334fd7d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67ac071dd83fcfa7dca895334fd7d62">&#9670;&nbsp;</a></span>callback() <span class="overload">[58/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="gafe12e4221e4d09ed112f0c88e2dacb12" name="gafe12e4221e4d09ed112f0c88e2dacb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe12e4221e4d09ed112f0c88e2dacb12">&#9670;&nbsp;</a></span>callback() <span class="overload">[59/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga7552a7b7668edfa77c5230504170642a" name="ga7552a7b7668edfa77c5230504170642a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7552a7b7668edfa77c5230504170642a">&#9670;&nbsp;</a></span>callback() <span class="overload">[60/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmbed_1_1_callback.html">Callback</a>&lt; R(A0, A1, A2, A3, A4)&gt; mbed::callback </td>
          <td>(</td>
          <td class="paramtype">volatile U *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(A0, A1, A2, A3, A4) volatile&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">method</td><td>Member function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>

</div>
</div>
<a id="ga598e97b15c4d90f94aa1d1668d5cdcd0" name="ga598e97b15c4d90f94aa1d1668d5cdcd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga598e97b15c4d90f94aa1d1668d5cdcd0">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga44f9e781941d03580345c71175307b53" name="ga44f9e781941d03580345c71175307b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44f9e781941d03580345c71175307b53">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga10bb79c4ef863bc9917cbf446d7d0568" name="ga10bb79c4ef863bc9917cbf446d7d0568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10bb79c4ef863bc9917cbf446d7d0568">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="gae58d69f185c10e920930a5dd1aebeca4" name="gae58d69f185c10e920930a5dd1aebeca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae58d69f185c10e920930a5dd1aebeca4">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga523a7324cf927bf9614efeb64c557d66" name="ga523a7324cf927bf9614efeb64c557d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga523a7324cf927bf9614efeb64c557d66">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000048">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
<a id="ga301526d02ad11b9014ffd1e03bc577b9" name="ga301526d02ad11b9014ffd1e03bc577b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga301526d02ad11b9014ffd1e03bc577b9">&#9670;&nbsp;</a></span>MBED_DEPRECATED_SINCE() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename R , typename A0 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mbed::MBED_DEPRECATED_SINCE </td>
          <td>(</td>
          <td class="paramtype">&quot;mbed-os-5.1&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Arguments to callback have been reordered to callback(func, arg)&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000032">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>
<p >Create a callback class with type inferred from the arguments</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Optional pointer to object to bind to function </td></tr>
    <tr><td class="paramname">func</td><td>Static function to attach </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmbed_1_1_callback.html">Callback</a> with inferred type </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>Arguments to callback have been reordered to callback(func, arg) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
