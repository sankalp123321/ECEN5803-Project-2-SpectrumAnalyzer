<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Signal Analyzer: critical section function</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Signal Analyzer
   </div>
   <div id="projectbrief">STM32 based Singal Analyzer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">critical section function<div class="ingroups"><a class="el" href="group__platform.html">Platform</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga44e8efe109debaecb97353942640531d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga44e8efe109debaecb97353942640531d">core_util_are_interrupts_enabled</a> (void)</td></tr>
<tr class="separator:ga44e8efe109debaecb97353942640531d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d5e75673fb04f46bfc89c2e5496f376"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga7d5e75673fb04f46bfc89c2e5496f376">core_util_is_isr_active</a> (void)</td></tr>
<tr class="separator:ga7d5e75673fb04f46bfc89c2e5496f376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d950b3bb0026db2d01df0efd5f18f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga4d950b3bb0026db2d01df0efd5f18f66">core_util_critical_section_enter</a> (void)</td></tr>
<tr class="separator:ga4d950b3bb0026db2d01df0efd5f18f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fbfbd322e41f1f0709332af8c3afc52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga9fbfbd322e41f1f0709332af8c3afc52">core_util_critical_section_exit</a> (void)</td></tr>
<tr class="separator:ga9fbfbd322e41f1f0709332af8c3afc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02717562c60bfbad511a2eb1a1495bad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga02717562c60bfbad511a2eb1a1495bad">core_util_in_critical_section</a> (void)</td></tr>
<tr class="separator:ga02717562c60bfbad511a2eb1a1495bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c9ab0fa7ce3b902356e10951e622198"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga3c9ab0fa7ce3b902356e10951e622198">core_util_atomic_cas_u8</a> (volatile uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue)</td></tr>
<tr class="separator:ga3c9ab0fa7ce3b902356e10951e622198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95a29dd5791c91987be0fed54796f08e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga95a29dd5791c91987be0fed54796f08e">core_util_atomic_cas_u16</a> (volatile uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue)</td></tr>
<tr class="separator:ga95a29dd5791c91987be0fed54796f08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f1b5edfdabd05b7b2fc400a56e1f9b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga8f1b5edfdabd05b7b2fc400a56e1f9b2">core_util_atomic_cas_u32</a> (volatile uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue)</td></tr>
<tr class="separator:ga8f1b5edfdabd05b7b2fc400a56e1f9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e9cbb15b6cae6154a5f85b483e9358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#gaf9e9cbb15b6cae6154a5f85b483e9358">core_util_atomic_cas_ptr</a> (void *volatile *ptr, void **expectedCurrentValue, void *desiredValue)</td></tr>
<tr class="separator:gaf9e9cbb15b6cae6154a5f85b483e9358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2738cdb036dd4bf42c8a496107b3c9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga7b2738cdb036dd4bf42c8a496107b3c9">core_util_atomic_incr_u8</a> (volatile uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="separator:ga7b2738cdb036dd4bf42c8a496107b3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11cb4e3404afe3549a26c852934c8df"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#gaf11cb4e3404afe3549a26c852934c8df">core_util_atomic_incr_u16</a> (volatile uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="separator:gaf11cb4e3404afe3549a26c852934c8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a9fd9661ae1db338cd776ba45f3ad33"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga4a9fd9661ae1db338cd776ba45f3ad33">core_util_atomic_incr_u32</a> (volatile uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="separator:ga4a9fd9661ae1db338cd776ba45f3ad33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552c51b9a90675e7f5c70d3769e2c5e8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga552c51b9a90675e7f5c70d3769e2c5e8">core_util_atomic_incr_ptr</a> (void *volatile *valuePtr, ptrdiff_t delta)</td></tr>
<tr class="separator:ga552c51b9a90675e7f5c70d3769e2c5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c32f3db5d87ca5ba9661f9efbaa205"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga22c32f3db5d87ca5ba9661f9efbaa205">core_util_atomic_decr_u8</a> (volatile uint8_t *valuePtr, uint8_t delta)</td></tr>
<tr class="separator:ga22c32f3db5d87ca5ba9661f9efbaa205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732744dc1479c273c7f096117a92ff83"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga732744dc1479c273c7f096117a92ff83">core_util_atomic_decr_u16</a> (volatile uint16_t *valuePtr, uint16_t delta)</td></tr>
<tr class="separator:ga732744dc1479c273c7f096117a92ff83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5cff540da859622ef0fce52f2c25bc6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#gaa5cff540da859622ef0fce52f2c25bc6">core_util_atomic_decr_u32</a> (volatile uint32_t *valuePtr, uint32_t delta)</td></tr>
<tr class="separator:gaa5cff540da859622ef0fce52f2c25bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43270010ce23b14d180cac14b0070137"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__platform__critical.html#ga43270010ce23b14d180cac14b0070137">core_util_atomic_decr_ptr</a> (void *volatile *valuePtr, ptrdiff_t delta)</td></tr>
<tr class="separator:ga43270010ce23b14d180cac14b0070137"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga44e8efe109debaecb97353942640531d" name="ga44e8efe109debaecb97353942640531d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44e8efe109debaecb97353942640531d">&#9670;&nbsp;</a></span>core_util_are_interrupts_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_are_interrupts_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine the current interrupts enabled state</p>
<p >This function can be called to determine whether or not interrupts are currently enabled. </p><dl class="section note"><dt>Note</dt><dd>NOTE: This function works for both cortex-A and cortex-M, although the underlying implementation differs. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if interrupts are enabled, false otherwise </dd></dl>

</div>
</div>
<a id="gaf9e9cbb15b6cae6154a5f85b483e9358" name="gaf9e9cbb15b6cae6154a5f85b483e9358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9e9cbb15b6cae6154a5f85b483e9358">&#9670;&nbsp;</a></span>core_util_atomic_cas_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. </dd></dl>

</div>
</div>
<a id="ga95a29dd5791c91987be0fed54796f08e" name="ga95a29dd5791c91987be0fed54796f08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95a29dd5791c91987be0fed54796f08e">&#9670;&nbsp;</a></span>core_util_atomic_cas_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. </dd></dl>

</div>
</div>
<a id="ga8f1b5edfdabd05b7b2fc400a56e1f9b2" name="ga8f1b5edfdabd05b7b2fc400a56e1f9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f1b5edfdabd05b7b2fc400a56e1f9b2">&#9670;&nbsp;</a></span>core_util_atomic_cas_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. } </dd></dl>

</div>
</div>
<a id="ga3c9ab0fa7ce3b902356e10951e622198" name="ga3c9ab0fa7ce3b902356e10951e622198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c9ab0fa7ce3b902356e10951e622198">&#9670;&nbsp;</a></span>core_util_atomic_cas_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_atomic_cas_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>expectedCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desiredValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic compare and set. It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail due to a mismatched expectedCurrentValue.</p>
<p >Refer to <a href="https://en.wikipedia.org/wiki/Compare-and-set">https://en.wikipedia.org/wiki/Compare-and-set</a> [which may redirect you to the article on compare-and swap].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ptr</td><td>The target memory location. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expectedCurrentValue</td><td>A pointer to some location holding the expected current value of the data being set atomically. The computed 'desiredValue' should be a function of this current value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is an in-out parameter. In the failure case of atomic_cas (where the destination isn't set), the pointee of expectedCurrentValue is updated with the current value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desiredValue</td><td>The new value computed based on '*expectedCurrentValue'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the memory location was atomically updated with the desired value (after verifying that it contained the expectedCurrentValue), false otherwise. In the failure case, exepctedCurrentValue is updated with the new value of the target memory location.</dd></dl>
<p>pseudocode: function cas(p : pointer to int, old : pointer to int, new : int) returns bool { if *p != *old { *old = *p return false } *p = new return true }</p>
<dl class="section note"><dt>Note</dt><dd>: In the failure case (where the destination isn't set), the value pointed to by expectedCurrentValue is instead updated with the current value. This property helps writing concise code for the following incr:</dd></dl>
<p>function incr(p : pointer to int, a : int) returns int { done = false value = *p // This fetch operation need not be atomic. while not done { done = atomic_cas(p, &amp;value, value + a) // *value gets updated automatically until success } return value + a }</p>
<dl class="section note"><dt>Note</dt><dd>: This corresponds to the C11 "atomic_compare_exchange_strong" - it always succeeds if the current value is expected, as per the pseudocode above; it will not spuriously fail as "atomic_compare_exchange_weak" may. </dd></dl>

</div>
</div>
<a id="ga43270010ce23b14d180cac14b0070137" name="ga43270010ce23b14d180cac14b0070137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43270010ce23b14d180cac14b0070137">&#9670;&nbsp;</a></span>core_util_atomic_decr_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_decr_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The type of the pointer argument is not taken into account and the pointer is decremented by bytes </dd></dl>

</div>
</div>
<a id="ga732744dc1479c273c7f096117a92ff83" name="ga732744dc1479c273c7f096117a92ff83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga732744dc1479c273c7f096117a92ff83">&#9670;&nbsp;</a></span>core_util_atomic_decr_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_decr_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a id="gaa5cff540da859622ef0fce52f2c25bc6" name="gaa5cff540da859622ef0fce52f2c25bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5cff540da859622ef0fce52f2c25bc6">&#9670;&nbsp;</a></span>core_util_atomic_decr_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_decr_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a id="ga22c32f3db5d87ca5ba9661f9efbaa205" name="ga22c32f3db5d87ca5ba9661f9efbaa205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22c32f3db5d87ca5ba9661f9efbaa205">&#9670;&nbsp;</a></span>core_util_atomic_decr_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_decr_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic decrement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being decremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being decremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new decremented value. </dd></dl>

</div>
</div>
<a id="ga552c51b9a90675e7f5c70d3769e2c5e8" name="ga552c51b9a90675e7f5c70d3769e2c5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga552c51b9a90675e7f5c70d3769e2c5e8">&#9670;&nbsp;</a></span>core_util_atomic_incr_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * core_util_atomic_incr_ptr </td>
          <td>(</td>
          <td class="paramtype">void *volatile *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptrdiff_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The type of the pointer argument is not taken into account and the pointer is incremented by bytes. </dd></dl>

</div>
</div>
<a id="gaf11cb4e3404afe3549a26c852934c8df" name="gaf11cb4e3404afe3549a26c852934c8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf11cb4e3404afe3549a26c852934c8df">&#9670;&nbsp;</a></span>core_util_atomic_incr_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t core_util_atomic_incr_u16 </td>
          <td>(</td>
          <td class="paramtype">volatile uint16_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a id="ga4a9fd9661ae1db338cd776ba45f3ad33" name="ga4a9fd9661ae1db338cd776ba45f3ad33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a9fd9661ae1db338cd776ba45f3ad33">&#9670;&nbsp;</a></span>core_util_atomic_incr_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t core_util_atomic_incr_u32 </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a id="ga7b2738cdb036dd4bf42c8a496107b3c9" name="ga7b2738cdb036dd4bf42c8a496107b3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b2738cdb036dd4bf42c8a496107b3c9">&#9670;&nbsp;</a></span>core_util_atomic_incr_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t core_util_atomic_incr_u8 </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Atomic increment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valuePtr</td><td>Target memory location being incremented. </td></tr>
    <tr><td class="paramname">delta</td><td>The amount being incremented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new incremented value. </dd></dl>

</div>
</div>
<a id="ga4d950b3bb0026db2d01df0efd5f18f66" name="ga4d950b3bb0026db2d01df0efd5f18f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d950b3bb0026db2d01df0efd5f18f66">&#9670;&nbsp;</a></span>core_util_critical_section_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_critical_section_enter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Mark the start of a critical section</p>
<p >This function should be called to mark the start of a critical section of code. </p><dl class="section note"><dt>Note</dt><dd>NOTES: 1) The use of this style of critical section is targetted at C based implementations. 2) These critical sections can be nested. 3) The interrupt enable state on entry to the first critical section (of a nested set, or single section) will be preserved on exit from the section. 4) This implementation will currently only work on code running in privileged mode. </dd></dl>

</div>
</div>
<a id="ga9fbfbd322e41f1f0709332af8c3afc52" name="ga9fbfbd322e41f1f0709332af8c3afc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fbfbd322e41f1f0709332af8c3afc52">&#9670;&nbsp;</a></span>core_util_critical_section_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void core_util_critical_section_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Mark the end of a critical section</p>
<p >This function should be called to mark the end of a critical section of code. </p><dl class="section note"><dt>Note</dt><dd>NOTES: 1) The use of this style of critical section is targetted at C based implementations. 2) These critical sections can be nested. 3) The interrupt enable state on entry to the first critical section (of a nested set, or single section) will be preserved on exit from the section. 4) This implementation will currently only work on code running in privileged mode. </dd></dl>

</div>
</div>
<a id="ga02717562c60bfbad511a2eb1a1495bad" name="ga02717562c60bfbad511a2eb1a1495bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02717562c60bfbad511a2eb1a1495bad">&#9670;&nbsp;</a></span>core_util_in_critical_section()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_in_critical_section </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine if we are currently in a critical section</p>
<dl class="section return"><dt>Returns</dt><dd>true if in a critical section, false otherwise. </dd></dl>

</div>
</div>
<a id="ga7d5e75673fb04f46bfc89c2e5496f376" name="ga7d5e75673fb04f46bfc89c2e5496f376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d5e75673fb04f46bfc89c2e5496f376">&#9670;&nbsp;</a></span>core_util_is_isr_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool core_util_is_isr_active </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Determine if this code is executing from an interrupt</p>
<p >This function can be called to determine if the code is running on interrupt context. </p><dl class="section note"><dt>Note</dt><dd>NOTE: This function works for both cortex-A and cortex-M, although the underlying implementation differs. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if in an isr, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
